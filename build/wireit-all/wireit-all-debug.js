/* This file is auto-generated by src/loader/scripts/meta_join.js */

YUI().use(function(Y) {
   var CONFIG = {
      groups: {
         'wireit': {
            base: 'wireit/src/',
            combine: false,
            modules: {
    "arrow-wire": {
        "requires": [
            "wire-base"
        ]
    },
    "bezier-wire": {
        "requires": [
            "wire-base"
        ]
    },
    "bidirectional-arrow-wire": {
        "requires": [
            "wire-base"
        ]
    },
    "container": {
        "requires": [
            "container-base",
            "widget-icons"
        ],
        "skinnable": true
    },
    "container-base": {
        "requires": [
            "overlay",
            "widget-parent",
            "widget-child",
            "dd",
            "resize",
            "terminal",
            "wires-delegate"
        ]
    },
    "form-container": {
        "requires": [
            "container",
            "inputex-wirable-fields"
        ],
        "skinnable": true
    },
    "image-container": {
        "requires": [
            "container-base"
        ]
    },
    "inout-container": {
        "requires": [
            "container"
        ]
    },
    "inputex-wirable": {
        "requires": [
            "terminal",
            "inputex-field"
        ]
    },
    "inputex-wirable-fields": {
        "requires": [
            "inputex-wirable",
            "inputex-group",
            "inputex-string",
            "inputex-list"
        ]
    },
    "layer": {
        "requires": [
            "widget-parent",
            "container",
            "wires-delegate"
        ],
        "skinnable": "true"
    },
    "straight-wire": {
        "requires": [
            "wire-base"
        ]
    },
    "terminal": {
        "requires": [
            "terminal-base",
            "terminal-dragedit",
            "terminal-scissors",
            "terminal-ddgroups"
        ],
        "skinnable": true
    },
    "terminal-base": {
        "requires": [
            "widget",
            "widget-child",
            "widget-position",
            "widget-position-align",
            "wire-base",
            "wires-delegate"
        ]
    },
    "terminal-ddgroups": {
        "requires": [
            "terminal-dragedit"
        ]
    },
    "terminal-dragedit": {
        "requires": [
            "bezier-wire",
            "dd-drop",
            "dd-drag",
            "dd-proxy"
        ]
    },
    "terminal-input": {
        "requires": [
            "terminal"
        ]
    },
    "terminal-output": {
        "requires": [
            "terminal"
        ]
    },
    "terminal-scissors": {
        "requires": [
            "overlay"
        ]
    },
    "textarea-container": {
        "requires": [
            "container"
        ]
    },
    "widget-icons": {
        "requires": [],
        "skinnable": true
    },
    "wire-base": {
        "requires": [
            "graphics"
        ],
        "skinnable": true
    },
    "wireit-app": {
        "requires": [
            "app",
            "handlebars",
            "model",
            "model-list",
            "json",
            "view",
            "layer",
            "bezier-wire",
            "anim"
        ]
    },
    "wires-delegate": {
        "requires": [
            "wire-base"
        ]
    }
}
         }
      }
   };

   if(typeof YUI_config === 'undefined') { 
      YUI_config = {groups: {}}; 
   }
   else if(YUI_config.groups.inputex) {
      
      // inputex-wirable trick
      // replace all 'inputex-field' dependencies in inputEx by 'inputex-wirable'
      for(var k in YUI_config.groups.inputex.modules) {
         if(YUI_config.groups.inputex.modules.hasOwnProperty(k)) {
            var m = YUI_config.groups.inputex.modules[k];
            if(m.requires) {
               var index = m.requires.indexOf('inputex-field');
               if(index != -1) {
                  m.requires[index] = 'inputex-wirable';
               }
            }
         }
      }
      
   }
   Y.mix(YUI_config.groups, CONFIG.groups);

});

YUI.add('arrow-wire', function (Y, NAME) {

    'use strict';

    /**
     * @module arrow-wire
     */

    /**
     * Extend CanvasWire to draw an arrow wire
     * @class ArrowWire
     * @extends WireBase
     * @constructor
     * @param {Object} cfg the configuration for the ArrowWire attributes
     */
    Y.ArrowWire = function (cfg) {
        Y.ArrowWire.superclass.constructor.apply(this, arguments);
    };

    Y.ArrowWire.NAME = "arrowwire";

    Y.extend(Y.ArrowWire, Y.WireBase, {
        /**
         * @method _draw
         * @private
         */
        _draw: function () {

            var d = 7, // arrow width/2
                redim = d + 3, //we have to make the canvas a little bigger because of arrows
                margin=[4 + redim,4 + redim],

                src = this.get('src').getXY(),
                tgt = this.get('tgt').getXY(),

                distance=Math.sqrt(Math.pow(src[0]-tgt[0],2) + Math.pow(src[1]-tgt[1],2));

            this.moveTo((src[0] + 6), (src[1] + 6));
            this.lineTo((tgt[0] + 6), (tgt[1] + 6));

            // start drawing arrows

            var z = [0,0], //point on the wire with constant distance (dlug) from terminal2
                dlug = 20, //arrow length
                t = (distance === 0) ? 0 : 1 - (dlug/distance);

            z[0] = Math.abs( src[0] + t * (tgt[0] - src[0]) );
            z[1] = Math.abs( src[1] + t * (tgt[1] - src[1]) );

            //line which connects the terminals: y=ax+b
            var W = src[0] - tgt[0],
                Wa = src[1] - tgt[1],
                Wb = src[0] * tgt[1] - src[1] * tgt[0],
                a, b, aProst, bProst;
         
            if (W !== 0) {
                a = Wa / W;
                b = Wb / W;
            } else {
                a = 0;
            }
            //line perpendicular to the main line: y = aProst*x + b
            if (a === 0) {
                aProst = 0;
            } else {
                aProst = -1 / a;
            }
            bProst = z[1] - aProst * z[0]; //point z lays on this line
            
            // we have to calculate coordinates of 2 points, which lay on perpendicular line and have the same distance (d) from point z
            var A = 1 + Math.pow(aProst, 2),
                B = 2 * aProst * bProst - 2 * z[0] - 2 * z[1] * aProst,
                C = -2 * z[1] * bProst + Math.pow(z[0], 2) + Math.pow(z[1], 2) - Math.pow(d, 2) + Math.pow(bProst, 2);

            var delta = Math.pow(B, 2) - 4 * A * C;
            if (delta < 0) { return; }
            
            var x1 = (-B + Math.sqrt(delta)) / (2 * A),
                x2 = (-B - Math.sqrt(delta)) / (2 * A),
                y1 = aProst * x1 + bProst,
                y2 = aProst * x2 + bProst;
            
            if (src[1] === tgt[1]) {
                var o = (src[0] > tgt[0]) ? 1 : -1;
                x1 = tgt[0] + o * dlug;
                x2 = x1;
                y1 -= d;
                y2 += d;
            }

            //triangle border
            this.moveTo(tgt[0] + 6, tgt[1] + 6);
            this.lineTo(x1 + 6, y1 + 6);
            this.moveTo(tgt[0] + 6, tgt[1] + 6);
            this.lineTo(x2 + 6, y2 + 6);
            this.end();
        }
    });

    Y.ArrowWire.ATTRS = Y.merge(Y.WireBase.ATTRS, {});


}, '@VERSION@', {"requires": ["wire-base"]});
YUI.add('bezier-wire', function (Y, NAME) {

/**
 * @module bezier-wire
 */

/**
 * Extend WireBase to draw a bezier curve
 * @class BezierWire
 * @extends WireBase
 * @constructor
 * @param {Object} config the configuration for the BezierWire attributes
 */
Y.BezierWire = function (cfg) {
   Y.BezierWire.superclass.constructor.apply(this, arguments);
};

Y.BezierWire.NAME = "bezierwire";

Y.extend(Y.BezierWire, Y.WireBase, {
   
   /**
    * Draw the bezier curve.
    * The canvas is made bigger to contain the curls
    * @method _draw
    * @method private
    */
    _draw: function () {
        
        this.clear();
        
        var src = this.get('src').getXY();
        var tgt = this.get('tgt').getXY();
        
        var srcDir = this.get('srcDir');
        var tgtDir = this.get('tgtDir');
        var bezierTangentNorm = this.get('bezierTangentNorm');
         
         var terminalSize = 14/2;
         
        this.moveTo(src[0]+terminalSize,src[1]+terminalSize);
        
        this.curveTo(src[0]+terminalSize+srcDir[0]*bezierTangentNorm,
                     src[1]+terminalSize+srcDir[1]*bezierTangentNorm, 
                     
                     tgt[0]+terminalSize+tgtDir[0]*bezierTangentNorm,
                     tgt[1]+terminalSize+tgtDir[1]*bezierTangentNorm, 
                     
                     tgt[0]+terminalSize,
                     tgt[1]+terminalSize);
        
        this.end();
     },
   
   
   
   SERIALIZABLE_ATTRS: ["color","width","bezierTangentNorm"]
   
});

Y.BezierWire.ATTRS = Y.merge(Y.WireBase.ATTRS, {
   
   /** 
    * Norm of the tangeant vector at the endpoints.
    * @attribute bezierTangentNorm
    * @default 100
    * @type Integer
    */
   bezierTangentNorm: {
      setter: function (val) {
         return parseInt(val, 10);
      },
      value: 200
   }

});



}, '@VERSION@', {"requires": ["wire-base"]});
YUI.add('bidirectional-arrow-wire', function (Y, NAME) {

/**
 * @module straight-wire
 */

/**
 * BidirectionalArrowWire
 * @class BidirectionalArrowWire
 * @extends WireBase
 * @constructor
 * @param {Object} config the configuration for the BezierWire attributes
 */
Y.BidirectionalArrowWire = function (cfg) {
   Y.BidirectionalArrowWire.superclass.constructor.apply(this, arguments);
};

Y.BidirectionalArrowWire.NAME = "bidirectionalarrowwire";

Y.extend(Y.BidirectionalArrowWire, Y.WireBase, {
   
   /**
    * @method _draw
    * @private
    */
   _draw: function () {
      
      var d = 7; // arrow width/2
      var redim = d+3; //we have to make the canvas a little bigger because of arrows
      var margin=[4+redim,4+redim];
     
      var src = this.get('src').getXY();
        var tgt = this.get('tgt').getXY();
      
      var distance=Math.sqrt(Math.pow(src[0]-tgt[0],2)+Math.pow(src[1]-tgt[1],2));
      this.moveTo((src[0]+6), (src[1]+6));
      this.lineTo((tgt[0]+6), (tgt[1]+6));
        
      // start drawing arrows

      var t1 = src;
      var t2 = tgt;

      var z = [0,0]; //point on the wire with constant distance (dlug) from terminal2
      var dlug = 20; //arrow length
      var t = (distance === 0) ? 0 : 1-(dlug/distance);
      z[0] = Math.abs( t1[0] +  t*(t2[0]-t1[0]) );
      z[1] = Math.abs( t1[1] + t*(t2[1]-t1[1]) );   

      //line which connects the terminals: y=ax+b
      var W = t1[0] - t2[0];
      var Wa = t1[1] - t2[1];
      var Wb = t1[0]*t2[1] - t1[1]*t2[0];
      if (W !== 0) {
         a = Wa/W;
         b = Wb/W;
      }
      else {
         a = 0;
      }
      //line perpendicular to the main line: y = aProst*x + b
      if (a === 0) {
         aProst = 0;
      }
      else {
         aProst = -1/a;
      }
      bProst = z[1] - aProst*z[0]; //point z lays on this line

      //we have to calculate coordinates of 2 points, which lay on perpendicular line and have the same distance (d) from point z
      var A = 1 + Math.pow(aProst,2);
      var B = 2*aProst*bProst - 2*z[0] - 2*z[1]*aProst;
      var C = -2*z[1]*bProst + Math.pow(z[0],2) + Math.pow(z[1],2) - Math.pow(d,2) + Math.pow(bProst,2);
      var delta = Math.pow(B,2) - 4*A*C;
      if (delta < 0) { return; }
         
      var x1 = (-B + Math.sqrt(delta)) / (2*A);
      var x2 = (-B - Math.sqrt(delta)) / (2*A);    
      var y1 = aProst*x1 + bProst;
      var y2 = aProst*x2 + bProst;
      
      if(t1[1] == t2[1]) {
           var o = (t1[0] > t2[0]) ? 1 : -1;
            x1 = t2[0]+o*dlug;
            x2 = x1;
            y1 -= d;
            y2 += d;
      }      

      this.moveTo(t2[0]+6,t2[1]+6);
      this.lineTo(x1+6,y1+6);
      this.moveTo(t2[0]+6,t2[1]+6);
      this.lineTo(x2+6,y2+6);

      t1 = tgt;
      t2 = src;

      var z = [0,0]; //point on the wire with constant distance (dlug) from terminal2
      var dlug = 20; //arrow length
      var t = (distance == 0) ? 0 : 1-(dlug/distance);
      z[0] = Math.abs( t1[0] +  t*(t2[0]-t1[0]) );
      z[1] = Math.abs( t1[1] + t*(t2[1]-t1[1]) );   

      //line which connects the terminals: y=ax+b
      var W = t1[0] - t2[0];
      var Wa = t1[1] - t2[1];
      var Wb = t1[0]*t2[1] - t1[1]*t2[0];
      if (W !== 0) {
         a = Wa/W;
         b = Wb/W;
      }
      else {
         a = 0;
      }
      //line perpendicular to the main line: y = aProst*x + b
      if (a == 0) {
         aProst = 0;
      }
      else {
         aProst = -1/a;
      }
      bProst = z[1] - aProst*z[0]; //point z lays on this line

      //we have to calculate coordinates of 2 points, which lay on perpendicular line and have the same distance (d) from point z
      var A = 1 + Math.pow(aProst,2);
      var B = 2*aProst*bProst - 2*z[0] - 2*z[1]*aProst;
      var C = -2*z[1]*bProst + Math.pow(z[0],2) + Math.pow(z[1],2) - Math.pow(d,2) + Math.pow(bProst,2);
      var delta = Math.pow(B,2) - 4*A*C;
      if (delta < 0) { return; }
         
      var x1 = (-B + Math.sqrt(delta)) / (2*A);
      var x2 = (-B - Math.sqrt(delta)) / (2*A);    
      var y1 = aProst*x1 + bProst;
      var y2 = aProst*x2 + bProst;
      
      if(t1[1] == t2[1]) {
           var o = (t1[0] > t2[0]) ? 1 : -1;
            x1 = t2[0]+o*dlug;
            x2 = x1;
            y1 -= d;
            y2 += d;
      }      

      this.moveTo(t2[0]+6,t2[1]+6);
      this.lineTo(x1+6,y1+6);
      this.moveTo(t2[0]+6,t2[1]+6);
      this.lineTo(x2+6,y2+6);      
      
      this.end();
   
   }
   
   
});

Y.BidirectionalArrowWire.ATTRS = Y.merge(Y.WireBase.ATTRS, {});


}, '@VERSION@', {"requires": ["wire-base"]});
YUI.add('container', function (Y, NAME) {

    'use strict';

/**
 * @module container
 */

/**
 * Container is an Overlay (XY positioning)
 * It is a WidgetChild (belongs to Layer)
 * It is also a WidgetParent (has many terminals)
 * @class Container
 * @extends ContainerBase
 */
    Y.Container = Y.Base.create("container", Y.ContainerBase, [Y.WidgetIcons], {
        /**
         * Click handler for the close icon
         * @method _onCloseClick
         * @private
         */
        _onCloseClick: function () {
            this.destroy();
        }

    }, {

        ATTRS: {
            /**
             * Override the default value of WidgetIcons to add the close button
             * @attribute icons
             */
            icons: {
                value: [
                    {title: 'close', click: '_onCloseClick', className: 'ui-silk ui-silk-cancel'}
                ]
            }
        }
    });



}, '@VERSION@', {"requires": ["container-base", "widget-icons"], "skinnable": true});
YUI.add('container-base', function (Y, NAME) {

/**
 * @module container-base
 */

/**
 * ContainerBase is an Overlay (XY positioning)
 * It is a WidgetChild (belongs to Layer)
 * It is also a WidgetParent (has many terminals)
 * @class ContainerBase
 * @extends Overlay
 * @uses WidgetParent
 * @uses WidgetChild
 * @uses WiresDelegate
 * @constructor
 */
var ContainerBase = Y.Base.create('container-base', Y.Overlay, [Y.WidgetParent, Y.WidgetChild, Y.WiresDelegate], {
   
   /**
    * @method renderUI
    */
   renderUI: function () {
      
      // make the overlay draggable
      this.drag = new Y.DD.Drag({
         node: this.get('boundingBox'), 
         handles : [ this._findStdModSection(Y.WidgetStdMod.HEADER) ]
      });
      
      this.drag.on('drag:drag', function () {
         this.redrawAllWires();
      }, this);
      
      // Make the overlay resizable
      if(this.get('resizable')) {
         var contentBox = this.get('contentBox');
         var resize = new Y.Resize({ 
            node: contentBox,
            handles: 'br'
         });
         /*resize.plug(Y.Plugin.ResizeConstrained, {
            minWidth: 50,
            minHeight: 50,
            maxWidth: 300,
            maxHeight: 300
            //preserveRatio: true
          });*/
         // On resize, fillHeight, & align terminals & wires
         resize.on('resize:resize', function () {
            // TODO: fillHeight
            this._fillHeight();
            this.alignTerminals();
            this.redrawAllWires();
         }, this);
         
         this.resize = resize;
      }
      
      // TODO: this is awful ! But we need to wait for everything to render & position
      Y.later(200, this, function () {
         this.alignTerminals();
      });
      
   },
   
   /**
    * @method alignTerminals
    */
   alignTerminals: function () {
      var contentBox = this.get('contentBox');
      this.each(function (term) {
         if(term.get('align')) {
            term.align( term.get('alignNode') || contentBox, ['tl',term.get('align').points[1]]);
         }
      }, this);
   },
   
   /**
    * @method syncUI
    */
   syncUI: function () {
      
      // Align terminals
      var c = this;
      this.each(function (term) {
         if(term.get('align')) {   
            term.align( c.get('contentBox') , ['tl',term.get('align').points[1]]);
         }
      });
      
   },
   
   SERIALIZABLE_ATTRS: ['x','y'],
   
   toJSON: function () {
      var o = {}, a = this;
      Y.Array.each(this.SERIALIZABLE_ATTRS, function (attr) {
         o[attr] = a.get(attr);
      });
      
      return o;
   },
   
   /**
    * Get a terminal by name
    * @method getTerminal
    */
   getTerminal: function (name) {
      return Y.Array.find(this._items, function (item) {
         if(item.get('name') == name) {
            return true;
         }
      });
   },
   
   destructor: function () {

      this.drag.destroy();
      
      if(this.resize) {
         this.resize.destroy();
      }
   }

}, {

   ATTRS: {
      
      /**
       * @attribute defaultChildType
       */
      defaultChildType: {
         value: 'Terminal'
      },
      
      /**
       * @attribute zIndex
       */
      zIndex: {
         value: 5
      },
      
      /**
       * @attribute resizable
       */
      resizable: {
         value: true
      },
      
      /**
       * @attribute fillHeight
       */
      fillHeight: {
         value: true
      },
      
      /*x: {
         getter: function () {
            var left = this.get('boundingBox').getStyle('left');
            return parseInt(left.substr(0,left.length-2),10);
         }
      },
      
      y: {
         getter: function () {
            var top = this.get('boundingBox').getStyle('top');
            return parseInt(top.substr(0,top.length-2),10);
         }
      },*/
      
      preventSelfWiring: {
         value: true
      }
      
   },
   
   EIGHT_POINTS: [
      { align: {points:['tl', 'tl']}, dir: [-0.5, -0.5], name: 'tl' },
      { align: {points:['tl', 'tc']}, dir: [0, -1], name: 'tc' },
      { align: {points:['tl', 'tr']}, dir: [0.5, -0.5], name: 'tr' },
      { align: {points:['tl', 'lc']}, dir: [-1, 0], name: 'lc' },
      { align: {points:['tl', 'rc']}, dir: [1, 0], name: 'rc' },
      { align: {points:['tl', 'br']}, dir: [0.5, 0.5], name: 'br' },
      { align: {points:['tl', 'bc']}, dir: [0,1], name: 'bc' },
      { align: {points:['tl', 'bl']}, dir: [-0.5, 0.5], name: 'bl' }
   ],

   FOUR_CORNERS: [
      { align: {points:['tl', 'tl']}, dir: [-0.5, -0.5], name: 'tl' },
      { align: {points:['tl', 'tr']}, dir: [0.5, -0.5], name: 'tr' },
      { align: {points:['tl', 'br']}, dir: [0.5, 0.5], name: 'br' },
      { align: {points:['tl', 'bl']}, dir: [-0.5, 0.5], name: 'bl' }
   ],

   FOUR_EDGES: [
      { align: {points:['tl', 'tc']}, dir: [0, -1], name: 'tc' },
      { align: {points:['tl', 'lc']}, dir: [-1, 0], name: 'lc' },
      { align: {points:['tl', 'rc']}, dir: [1, 0], name: 'rc' },
      { align: {points:['tl', 'bc']}, dir: [0,1], name: 'bc' }
   ]
   
});

Y.ContainerBase = ContainerBase;



}, '@VERSION@', {"requires": ["overlay", "widget-parent", "widget-child", "dd", "resize", "terminal", "wires-delegate"]});
YUI.add('form-container', function (Y, NAME) {

/**
 * @module form-container
 */

/**
 * Include the form library inputEx + WirableField + FormContainer<br />
 * <br />
 * <b>WARNING</b>: The "WirableField.js" file MUST be loaded AFTER "inputEx/field.js" and BEFORE all other inputEx fields !<br />
 * <br />
 * See the inputEx website for documentation of the fields & forms: <a href='http://neyric.github.com/inputex'>http://neyric.github.com/inputex</a><br />
 *
 * Class used to build a container with inputEx forms
 * @class FormContainer
 * @extends Container
 * @constructor
 * @param {Object}   options  Configuration object (see properties)
 * @param {Layer}   layer The Y.Layer (or subclass) instance that contains this container
 */
Y.FormContainer = Y.Base.create("form-container", Y.Container, [], {
   
   /**
    * @method renderUI
    */
   renderUI: function () {
      Y.FormContainer.superclass.renderUI.call(this);
      this._renderForm();
   },
   
   /**
    * Render the form in the widget body
    * @method _renderForm
    */
   _renderForm: function () {
      this.after('bodyContentChange', function () {
         var inputExContainer = this.getStdModNode(Y.WidgetStdMod.BODY).one('.inputex-container')._node;
         
         var that = this;
         this.form = new Y.inputEx.Group({
             parentEl: inputExContainer,
             fields: (new Y.Array(this.get('fields') ) ).map(function (i) {
                // add the container reference
                 return Y.mix({container: that}, i);
              })
         });
         
         this.form.setValue(this.get('value'));
         
         this.alignTerminals();
         
      }, this);
   },
   
   SERIALIZABLE_ATTRS: Y.Container.prototype.SERIALIZABLE_ATTRS.concat(['value'])
   
}, {

   ATTRS: {
      
      /**
       * Value of the form
       * @attribute value
       */
      value: {
         setter: function (val) {
            if(this.form) {
               return this.form.setValue(val);
            }
         },
         getter: function () {
            if(this.form) {
               return this.form.getValue();
            }
            else {
               return {};
            }
         }
      },
      
      /**
       * Keep to render the form
       * @attribute bodyContent
       */
      bodyContent: {
         value: '<div class="inputex-container" />'
      },
      
      /**
       * @attribute fields
       */
      fields: {
         value: []
      }//,
      
      /**
       * @attribute resizable
       */
      /*resizable: {
         value: false
      }*/
      
   }

});

   /** 
    * @attribute legend
    * @description Legend
    * @default null
    * @type String
    */
   //legend: null,

   /** 
    * @attribute collapsible
    * @description Collapsible
    * @default false
    * @type Boolean
    */
   //collapsible: false,
   
   /**
    * Render the form
    * @method renderForm
    */
   /*renderForm: function () {
   
      var groupParams = {parentEl: this.bodyEl, fields: this.fields, legend: this.legend, collapsible: this.collapsible};
      this.form = new Y.inputEx.Group(groupParams);
        this.form.setContainer(this);

         for(var i = 0 ; i < this.form.inputs.length ; i++) {
            var field = this.form.inputs[i];
            field.setContainer(this);
         }


      // Redraw all wires when the form is collapsed
      if(this.form.legend) {
         Y.one(this.form.legend).on('click', function () {
            
            // Override the getXY method on field terminals:
            var that = this;
            for(var i = 0 ; i < this.form.inputs.length ; i++) {
               var field = this.form.inputs[i];
               if(field.terminal) {
                  field.terminal.getXY = function () {
                     if( Y.one(that.form.fieldset).hasClass("inputEx-Collapsed") ) {
                        return that.getXY();
                     }
                     else {
                        return Y.Terminal.prototype.getXY.call(this);
                     }
                     
                  };
               }
            }
            
            this.redrawAllWires();
         }, this, true);
      }
   },*/
   
//});



}, '@VERSION@', {"requires": ["container", "inputex-wirable-fields"], "skinnable": true});
YUI.add('image-container', function (Y, NAME) {

/**
 * @module image-container
 */

/**
 * ImageContainer is an Overlay (XY positioning)
 * It is a WidgetChild (belongs to Layer)
 * It is also a WidgetParent (has many terminals)
 * @class ImageContainer
 * @extends ContainerBase
 * @constructor
 */
Y.ImageContainer = Y.Base.create("image-container", Y.ContainerBase, [], {
   
   /**
    * @method renderUI
    */
   renderUI: function () {
      
      // TODO: 
      var image = Y.Node.create('<img src="'+this.get('imageUrl')+'" width="'+this.get('width')+'"  height="'+this.get('height')+'"/>');
      image.appendTo( this.get('contentBox') );
      this.image = image;

      this.image.once('load', function() {
        //console.log("loaded !!!");
        this.alignTerminals();
        this.redrawAllWires();
      }, this);
      
      //console.log( Y.WidgetStdMod.BODY, this._getStdModContent(Y.WidgetStdMod.BODY) );
            
        // make the overlay draggable
      this.drag = new Y.DD.Drag({
           node: this.get('boundingBox'), 
         handles : [ image ]
        });
   
      this.drag.on('drag:drag', function () {
         this.redrawAllWires();
      }, this);
   
   
      // Make the overlay resizable
      if(this.get('resizable')) {
        var contentBox = this.get('contentBox');
        var resize = new Y.Resize({ 
           node: contentBox,
           handles: 'br'
        });
        /*resize.plug(Y.Plugin.ResizeConstrained, {
           preserveRatio: true
         });*/
        // On resize, fillHeight, & align terminals & wires
        resize.on('resize:resize', function (e) {
           // TODO: fillHeight
           this._fillHeight();
           
           //console.log(e.details[0].info);
           var p = e.details[0].info;
           var w = p.right-p.left;
           var h = p.bottom-p.top;
           //console.log(w+"x"+h);
           
           // WARNING !!!
           this.image.set('width',w);
           this.image.set('height',h);
           
           this.each(function (term) {
              if(term.get('align')) {   
                 term.align( contentBox, ["tl",term.get('align').points[1]]);
              }
           }, this);
           
           this.redrawAllWires();
        }, this);
      }
      
   }
   
}, {

   ATTRS: {
      /**
       * Url of the image you want to render (relative to the script's page)
       * @attribute imageUrl
       */
      imageUrl: {
         value: '',
         setter: function(url) {
            if(this.image) {
              this.image.set('src', url);
            }
         }
      },
      
      zIndex: {
         value: 5
      }
   }
   
});


}, '@VERSION@', {"requires": ["container-base"]});
YUI.add('inout-container', function (Y, NAME) {

/**
 * @module inout-container
 */

/**
 * Container with left inputs and right outputs
 * @class InOutContainer
 * @extends Container
 * @constructor
 * @param {Object} options
 * @param {Layer} layer
 */

Y.InOutContainer = Y.Base.create("inout-container", Y.Container, [], {

   /**
    * @method renderUI
    */
   renderUI: function () {
      Y.InOutContainer.superclass.renderUI.call(this);
      this._renderInputsOutputs();
   },
   
   /**
    * @method _renderInputsOutputs
    */
   _renderInputsOutputs: function () {
      
      var that = this;
      Y.on('available', function () {
         
         /*
            for(var i = 0 ; i < this.inputs.length ; i++) {
               var input = this.inputs[i];
               this.addTerminal({
                  "name": input, 
                  "direction": [-1,0], 
                  "offsetPosition": {"left": -14, "top": 3+30*(i+1) }, 
                  "ddConfig": {
                     "type": "input",
                     "allowedTypes": ["output"]
                  }
               });
               this.bodyEl.appendChild(Y.WireIt.cn('div', null, {lineHeight: "30px"}, input));
            }

            for(i = 0 ; i < this.outputs.length ; i++) {
               var output = this.outputs[i];
               this.addTerminal({
                  "name": output, 
                  "direction": [1,0], 
                  "offsetPosition": {"right": -14, "top": 3+30*(i+1+this.inputs.length) }, 
                  "ddConfig": {
                     "type": "output",
                     "allowedTypes": ["input"]
                  },
                  "alwaysSrc": true
               });
               this.bodyEl.appendChild(Y.WireIt.cn('div', null, {lineHeight: "30px", textAlign: "right"}, output));
            }
            */
         
         
      }, '#body-container');
      
   }
   
}, {

   ATTRS: {
      
      
      /**
       * Keep to render the form
       * @attribute bodyContent
       */
      bodyContent: {
         value: '<div id="body-container" />'
      },
      
      /**
       * @attribute inputs
       * @description Array of strings for which an Input terminal will be created.
       * @default []
       * @type Array
       */
      inputs: [],

      /**
       * @attribute outputs
       * @description Array of strings for which an Output terminal will be created.
       * @default []
       * @type Array
       */
      outputs: []
   }
   
});


}, '@VERSION@', {"requires": ["container"]});
YUI.add('inputex-wirable', function (Y, NAME) {

/**
 * @module inputex-wirable
 */

   var inputEx = Y.inputEx;

/**
 * Copy of the original inputEx.Field class that we're gonna override to extend it.
 * @class BaseField
 */
inputEx.BaseField = inputEx.Field;

/**
 * Class to make inputEx Fields "wirable".Re-create inputEx.Field adding the wirable properties
 * @class Field
 * @extends inputEx.BaseField
 */
inputEx.Field = function (options) {
   inputEx.Field.superclass.constructor.call(this,options);
};

Y.extend(inputEx.Field, inputEx.BaseField, {

   /**
    * Adds a wirable option to every field
    * @method setOptions
    */
   setOptions: function (options) {
      inputEx.Field.superclass.setOptions.call(this, options);
      
      this.options.wirable = Y.Lang.isUndefined(options.wirable) ? false : options.wirable;
      this.options.container = options.container;
   },
   
   /**
    * Adds a terminal to each field
    * @method render
    */
   render: function () {
      inputEx.Field.superclass.render.call(this);
      
      if(this.options.wirable) {
         this.renderTerminal();
      }
   },
   
   /**
    * Render the associated input terminal
    * @method renderTerminal
    */
   renderTerminal: function () {

      if(this.options.container) {
         this.terminal = this.options.container.add({
            name: this.options.name, 
            dir: [-1,0],
            alignNode: this.divEl,
            align: {"points":['tl', 'lc']}
         }).item(0);
         
         // Register the events
         this.terminal.on('addWire', this.onAddWire, this, true);
         this.terminal.on('removeWire', this.onRemoveWire, this, true);
      }
      
    },

   /**
    * Set the container for this field
    */
   setContainer: function (container) {
      if(!this.options.container) {
         this.renderTerminal();
      }
      this.options.container = container;
      /*if(this.terminal) {
         this.terminal.container = container;
         if( Y.Array.indexOf(container.terminals, this.terminal) == -1 ) {
            container.terminals.push(this.terminal);
         }
      }*/
   },

   /**
    * also change the terminal name when changing the field name
    */
   setFieldName: function (name) {
      if(this.terminal) {
         this.terminal.name = name;
         this.terminal.el.title = name;
      }
   },

    /**
     * Remove the input wired state on the 
     * @method onAddWire
     */
    onAddWire: function (e, params) {
       // TODO: this.options.container.onAddWire(e,params);

       this.disable();
       this.el.value = "[wired]";
    },

    /**
     * Remove the input wired state on the 
     * @method onRemoveWire
     */
    onRemoveWire: function (e, params) { 
       // TODO: this.options.container.onRemoveWire(e,params);

       this.enable();
       this.el.value = "";
    }

});

inputEx.Field.groupOptions = inputEx.BaseField.groupOptions.concat([
   { type: 'boolean', label: 'Wirable', name: 'wirable', value: false}
]);



}, '@VERSION@', {"requires": ["terminal", "inputex-field"]});
YUI.add('inputex-wirable-fields', function (Y, NAME) {

   
   var inputEx = Y.inputEx;
   
// this file ovveride many functions on inputEx fields to make them wirable

/**
 * setFieldName might change the name of the terminal
 */
inputEx.StringField.prototype.setFieldName = function (name) {
   this.el.name = name;
   if(this.terminal) {
      this.terminal.set('name', name);
      // TODO: this.terminal.el.title = name;
   }
};


/**
 * Groups must set the container recursively
 */
inputEx.Group.prototype.setContainer = function (container) {
   
   inputEx.Group.superclass.setContainer.call(this, container);
   
   // Group and inherited fields must set this recursively
   if(this.inputs) {
      for(var i = 0 ; i < this.inputs.length ; i++) {
         this.inputs[i].setContainer(container);
      }
   }
   
};


/**
 * List must set the container recursively
 */
inputEx.ListField.prototype.setContainer = function (container) {
   
   inputEx.ListField.superclass.setContainer.call(this, container);

   if(this.subFields) {
      for(var i = 0 ; i < this.subFields.length ; i++) {
         this.subFields[i].setContainer(container);
      }
   }
   
};

/**
 * setContainer must be called on each new element
 */
inputEx.ListField.prototype._addElement = inputEx.ListField.prototype.addElement;
inputEx.ListField.prototype.addElement = function (value) {
   var f = this._addElement(value);
   f.setContainer(this.options.container);
   return f;
};



}, '@VERSION@', {"requires": ["inputex-wirable", "inputex-group", "inputex-string", "inputex-list"]});
YUI.add('layer', function (Y, NAME) {

/**
 * @module layer
 */

/**
 * Layer : Widget to manage collections of wires (through WiresDelegate) and containers (trough WidgetParent)
 * @class Layer
 * @extends Widget
 * @uses WidgetParent
 * @uses WiresDelegate
 */
Y.Layer = Y.Base.create("layer", Y.Widget, [Y.WidgetParent, Y.WiresDelegate], {
   
   initializer: function () {
      
      this.graphic = new Y.Graphic({render: this.get('contentBox') }); 
      
   },
   
   
   /**
    * Alias method for WidgetParent.removeAll
    * @method clear
    */
   clear: function () {
      this.removeAll();
   }
   
}, {
   
   ATTRS: {
      
      defaultChildType: {
         value: 'Container'
      }
      
   }
   
});



}, '@VERSION@', {"requires": ["widget-parent", "container", "wires-delegate"], "skinnable": "true"});
YUI.add('straight-wire', function (Y, NAME) {

/**
 * @module straight-wire
 */

/**
 * Straight Wire
 * @class StraightWire
 * @extends WireBase
 * @constructor
 * @param {Object} cfg the configuration for the StraightWire attributes
 */
Y.StraightWire = function (cfg) {
   Y.StraightWire.superclass.constructor.apply(this, arguments);
};

Y.StraightWire.NAME = "straightwire";

Y.extend(Y.StraightWire, Y.WireBase, {
  
   /**
    * @method _draw
    * @private
    */
   _draw: function () {
      
      this.clear();
      
      var src = this.get('src').getXY();
      var tgt = this.get('tgt').getXY();
      
      this.moveTo((src[0]+6), (src[1]+6));
      this.lineTo((tgt[0]+6), (tgt[1]+6));
      this.end();
   }
   
});

Y.StraightWire.ATTRS = Y.merge(Y.WireBase.ATTRS, {});


}, '@VERSION@', {"requires": ["wire-base"]});
YUI.add('terminal', function (Y, NAME) {

/**
 * @module terminal
 */

    'use strict';

/**
 * Terminal is responsible for wire edition
 * 
 * @class Terminal
 * @extends TerminalBase
 * @uses TerminalDragEdit
 * @uses TerminalScissors
 * @uses TerminalDDGroups
 * @constructor
 * @param {Object} oConfigs The user configuration for the instance.
 */
    Y.Terminal = Y.Base.create("terminal", Y.TerminalBase, [Y.TerminalDragEdit, Y.TerminalScissors, Y.TerminalDDGroups]);




}, '@VERSION@', {
    "requires": [
        "terminal-base",
        "terminal-dragedit",
        "terminal-scissors",
        "terminal-ddgroups"
    ],
    "skinnable": true
});
YUI.add('terminal-base', function (Y, NAME) {

'use strict';

/**
 * @module terminal-base
 */

/**
 * Terminal is responsible for wire edition
 * @class TerminalBase
 * @constructor
 * @extends Widget
 * @uses WidgetChild
 * @uses WidgetPosition
 * @uses WidgetPositionAlign
 * @uses WiresDelegate
 * @param {Object} oConfigs The user configuration for the instance.
 */
Y.TerminalBase = Y.Base.create("terminal-base", Y.Widget, [Y.WidgetChild, Y.WidgetPosition, Y.WidgetPositionAlign, Y.WiresDelegate], {
   
   renderUI: function () {
      
      // For Overlay extensions such as Scissors or DDGroups
      var show = Y.bind(function () {
         var bb = this.get('boundingBox');
         if( bb ) {
            bb.addClass( this.getClassName("show-overlay") );
         }
      }, this);
      var hide = Y.bind(function () {
         var bb = this.get('boundingBox');
         if(bb) {
            bb.removeClass( this.getClassName("show-overlay") );
         }
      }, this);
      this.get('boundingBox').on('mouseover', function () { Y.later(300, this, show); });
      this.get('boundingBox').on('mouseout', function () { Y.later(300, this, hide); });
     

      var containerXY = this.get('parent').get('boundingBox').getXY();
      //var xy = this.get('xy');
      var offset = this.get('offset');

      this.set('xy', [containerXY[0]+offset[0], containerXY[1]+offset[1]]);
      //console.log(containerXY, xy, );

   },
   
   // override the WiresDelegate behavior which re-fires the event
   // add the connected class
   _onAddWire: function (e) {
      this.get('boundingBox').addClass(  this.getClassName("connected") );
   },
   
   // override the WiresDelegate behavior which re-fires the event
   // Remove the connected class if it has no more wires:
   _onRemoveWire: function (e) {
      if(this._wires.length === 0) {
         this.get('boundingBox').removeClass(  this.getClassName("connected") );
      }
   },
   
   /**
    * This function is a temporary test. I added the border width while traversing the DOM and
    * I calculated the offset to center the wire in the terminal just after its creation
    * @method getXY
    */
   getXY: function () {
      var container = this.get('parent');
      var layer = container.get('parent');
      var layerXY = layer.get('boundingBox').getXY();
      //console.log( "layerXY", layerXY );

      var absXY = this.get('contentBox').getXY();
      //console.log( "absXY", absXY );

      return [absXY[0]-layerXY[0] + 15/2 , absXY[1]-layerXY[1] + 15/2];
   }
   
}, {
   
   ATTRS: {
      
      name: {
         value: null
      },
      
      /**
       * Vector direction at the terminal
       * (used by BezierWire ou Scissors)
       * @attribute dir
       */
      dir: {
         value: [0,1]
      },
      
      alignNode: {
         value: null
      },

      offset: {
        setter: function(val) {
          //this._setX(val);
          var containerXY = this.get('parent').get('boundingBox').getXY();

          var xy = this.get('xy');

          console.log(containerXY, xy, val);
        },
        value: [0,0]
      }
      
   }
   
});




}, '@VERSION@', {
    "requires": [
        "widget",
        "widget-child",
        "widget-position",
        "widget-position-align",
        "wire-base",
        "wires-delegate"
    ]
});
YUI.add('terminal-ddgroups', function (Y, NAME) {

/**
 * @module terminal-ddgroups
 */

/**
 * Extension to add "groups" labels when hovering the terminal
 * @class TerminalDDGroups
 * @constructor
 * @param {Object} config configuration object
 */
Y.TerminalDDGroups = function (config) {
   Y.after(this._renderUIgroups, this, "renderUI");
};

Y.TerminalDDGroups.ATTRS = {
   
   /**
    * drag/drop groups : list of supported terminal types
    * only used if editable is set to true
    * @attribute groups
    */
   groups: {
      value: ['terminal']
   },
   
   showGroups: {
      value: true
   }
   
};

Y.TerminalDDGroups.prototype = {
   
   _renderUIgroups: function () {
      if( this.get('editable') ) {
         this._renderTooltip();
      }
   },
   
   /**
    * create a persisting tooltip with the scissors class
    * listen for click events on the tooltip and call destroyWires
    * @method _renderTooltip
    */
   _renderTooltip: function () {
      
      if(this.get('showGroups')) {
         
         var ddGroupsOverlay = new Y.Overlay({
            render: this.get('boundingBox'),
            bodyContent: this.get('groups').join(',')
         });
         ddGroupsOverlay.set("align", {node: this.get('contentBox'), 
                               points:[Y.WidgetPositionAlign.TC, Y.WidgetPositionAlign.BC]});

         ddGroupsOverlay.get('contentBox').addClass( this.getClassName("dd-groups") );
      }
      
   }
   
};



}, '@VERSION@', {"requires": ["terminal-dragedit"]});
YUI.add('terminal-dragedit', function (Y, NAME) {

/**
 * @module terminal-dragedit
 */

/**
 * Extension which makes the wires editable
 * @class TerminalDragEdit
 * @constructor
 * @param {Object} config configuration object
 */
Y.TerminalDragEdit = function (config) {

   Y.after(this._renderUIdragedit, this, "renderUI");
   Y.after(this._bindUIdragedit, this, "bindUI");
   var attrs = {
      "color":{value:"rgb(173,216,230)"},
      "weight":{value:4},
      "opacity":{value:1},
      "dashstyle":{value:"none"},
      "fill":{value:"rgb(255,255,255)"},
      "editwire-class": {value: Y.BezierWire}
   };
   this.addAttrs(attrs, config);   
};

Y.TerminalDragEdit.ATTRS = {
   
   /**
    * Sets the terminal editable
    * @attribute editable
    */
   editable: {
      value: true
   },
   
   /**
    * @attribute graphic
    */
   graphic: {
      value: null
   },
   
   /**
    * @attribute alwaysSrc
    */
   alwaysSrc: {
      value: false
   }
};

Y.TerminalDragEdit.prototype = {
   
   /**
    * @method _renderUIdragedit
    */
   _renderUIdragedit: function () {
      
      if( this.get('editable') ) {
         this.get('contentBox').addClass(  this.getClassName("editable") );
         
         // Make the contentBox draggable with a DDProxy
         var drag = new Y.DD.Drag({ 
            node: this.get('contentBox'),
               groups: this.get('groups')
         }).plug(Y.Plugin.DDProxy, {
            cloneNode: true,
            moveOnEnd: false
         });
         
         this.drag = drag;
         
         // Create the Drop object
         var drop = new Y.DD.Drop({
            node: this.get('contentBox'),
            groups: this.get('groups')
         });
         drop.terminal = this;
         this.drop = drop;
         
      }
      
   },
   
   /**
    * @method _bindUIdragedit
    */
   _bindUIdragedit: function () {
      var drag = this.drag;
      if(drag) {
         drag.on('drag:start',    this._onDragEditStart, this);
         drag.on('drag:drag',     this._onDragEditDrag, this);
         drag.on('drag:drophit',  this._onDragEditDrophit, this);
         drag.on('drag:dropmiss', this._onDragEditDropmiss, this);
         drag.on('drag:enter',    this._onDragEditEnter, this);
         drag.on('drag:exit',     this._onDragEditExit, this);
      }
   },
   
   /**
    * on drag start, create the wire between 2 fake terminals
    * @method _onDragEditStart
    */
   _onDragEditStart: function (ev) {
      // save the position
      this._editwireX = ev.pageX;
      this._editwireY = ev.pageY;
      
      var dir = this.get('dir');
      var that = this;
      
      if(!this.get('graphic')) {
         this.set('graphic', this.get('root').graphic);
      }


      var container = this.get('parent');
      var layer = container.get('parent');
      var offset = layer.get('boundingBox').getXY();
      
      this.drag.wire = this.get('graphic').addShape({
         
         type: this.get('editwire-class'),
         
         // TODO: customizable
         stroke: {
            weight: this.get('weight'),
           color: this.get('color'),
           opacity:this.get('opacity'),
           dashstyle:this.get('dashstyle'),
           fill:this.get('fill')
           },
           
           src: { 
              getXY: function () { return [ev.pageX - offset[0]  + 15 / 2, ev.pageY - offset[1] + 15 / 2]; }
           },
           tgt: { 
              getXY: function () { return [that._magnetX || (that._editwireX - offset[0] + 15 / 2),
                                           that._magnetY || (that._editwireY - offset[1] + 15 / 2)]; } 
           },

           srcDir: dir,
           tgtDir: [-dir[0],-dir[1]]

        });
      
      
   },
   
   /**
    * Update the position of the fake target and redraw the wire
    * @method _onDragEditDrag
    * @private
    */
   _onDragEditDrag: function (ev) {
      this._editwireX = ev.pageX;
      this._editwireY = ev.pageY;
      this.drag.wire._draw();
   },
   
   /**
    * on drop hit, set the wire src and tgt terminals
    * @method _onDragEditDrophit
    * @private
    */
   _onDragEditDrophit: function (ev) {
      
      if( this.isValidWireTerminal(ev.drop.terminal) ) {
         if(ev.drop.terminal.alwaysSrc){
            this.drag.wire.set('src', ev.drop.terminal);
            this.drag.wire.set('tgt', this);
         }else{
            this.drag.wire.set('src', this);
            this.drag.wire.set('tgt', ev.drop.terminal);
         }
         
         // Remove the reference to this wire
         this.drag.wire = null;
         
         // Reset the magnet position
         this._magnetX = null;
         this._magnetY = null;
      } else {
         this.drag.wire.destroy();
      }
   },
   
   /**
    * on drop miss, destroy the wire
    * @method _onDragEditDropmiss
    */
   _onDragEditDropmiss: function (ev) {
      this.drag.wire.destroy();
      this.drag.wire = null;
   },
   
   /**
    * @method _onDragEditEnter
    */
   _onDragEditEnter: function (ev) {
      
         var pos = ev.drop.terminal.getXY();
         this._magnetX = pos[0];
         this._magnetY = pos[1];
         
         // TODO: this only works for Bezier...
         this.drag.wire.set('tgtDir', ev.drop.terminal.get('dir'));
      
   },
   
   /**
    * @method _onDragEditExit
    */
   _onDragEditExit: function (ev) {
      this._magnetX = null;
      this._magnetY = null;
   },
   
   /**
    * @method isValidWireTerminal
    */
   isValidWireTerminal: function (DDterminal) {
     if(this.get('parent') !== undefined && (this.get('parent').get('preventSelfWiring'))){
        if (DDterminal._parentNode._node == this._parentNode._node) {
         return false;
        } 
     }
      return true;
   },
   
   /**
    * @method destructor
    */
   destructor: function () {
      
      if(this.drag) {
         this.drag.destroy();
      }
      if(this.drop) {
         this.drop.destroy();
      }
   }
   
};



}, '@VERSION@', {"requires": ["bezier-wire", "dd-drop", "dd-drag", "dd-proxy"]});
YUI.add('terminal-input', function (Y, NAME) {

/**
 * @module terminal-input
 */

/**
 * Class that extends Terminal to differenciate Input/Output terminals
 * @class TerminalInput
 * @extends Terminal
 * @constructor
 * @param {HTMLElement} parentEl Parent dom element
 * @param {Object} options configuration object
 * @param {Container} container (Optional) Container containing this terminal
 */
Y.TerminalInput = function (parentEl, options, container) {
   Y.TerminalInput.superclass.constructor.call(this,parentEl, options, container);
};
Y.extend(Y.TerminalInput, Y.Terminal, {
   
   /**
    * @attribute nMaxWires
    * @description maximum number of wires for this terminal
    * @type Integer
    * @default 1
    */
   nMaxWires: 1,
   
   /**
    * @attribute ddConfig
    * @description configuration of the Y.TerminalProxy object
    * @type Object
    * @default { type: "input", allowedTypes: ["output"] }
    */
   ddConfig: { type: "input", allowedTypes: ["output"] }
});



}, '@VERSION@', {"requires": ["terminal"]});
YUI.add('terminal-output', function (Y, NAME) {

/**
 * @module terminal-output
 */

/**
 * Class that extends Terminal to differenciate Input/Output terminals
 * @class TerminalOutput
 * @extends Terminal
 * @constructor
 * @param {HTMLElement} parentEl Parent dom element
 * @param {Object} options configuration object
 * @param {Container} container (Optional) Container containing this terminal
 */
Y.TerminalOutput = function (parentEl, options, container) {
   Y.TerminalOutput.superclass.constructor.call(this,parentEl, options, container);
};
Y.extend(Y.TerminalOutput, Y.Terminal, {
   
   /**
    * @attribute direction
    * @description direction vector of the wires when connected to this terminal
    * @type Array
    * @default [0,1]
    */
   direction: [0,1],
   
   /**
    * @attribute fakeDirection
    * @description direction vector of the "editing" wire when it started from this terminal
    * @type Array
    * @default [0,-1]
    */
   fakeDirection: [0,-1],
   
   /**
    * @attribute ddConfig
    * @description configuration of the Y.TerminalProxy object
    * @type Object
    * @default  { type: "output", allowedTypes: ["input"] }   
    */
   ddConfig: { type: "output", allowedTypes: ["input"] }   ,
   
   /**
    * @attribute alwaysSrc
    * @description forces this terminal to be the src terminal in the wire config
    * @type Boolean
    * @default true
    */
   alwaysSrc: true
   
});


}, '@VERSION@', {"requires": ["terminal"]});
YUI.add('terminal-scissors', function (Y, NAME) {

/**
 * @module terminal-scissors
 */

/**
 * @class TerminalScissors
 * @constructor
 * @param {Object} config configuration object
 */
Y.TerminalScissors = function (config) {
   
   Y.after(this._renderUIScissors, this, "renderUI");
   Y.after(this._bindUIScissors, this, "bindUI");
   
};

Y.TerminalScissors.ATTRS = {};

Y.TerminalScissors.prototype = {
   
   /**
    * @method _renderUIScissors
    * @private
    */
   _renderUIScissors: function () {
      if( this.get('editable') ) {
         this._renderScissors();
      }
   },
   
   /**
    * @method _bindUIScissors
    * @private
    */
   _bindUIScissors: function () {
      if( this.get('editable') ) {
         this._scissorsOverlay.get('boundingBox').on('click', this.destroyWires, this);
      }
   },
   
   /**
    * @method _renderScissors
    * @private
    */
   _renderScissors: function () {
      this._scissorsOverlay = new Y.Overlay({});
      
      this._scissorsOverlay.get('contentBox').addClass( this.getClassName("scissors") );
      
      // Position the scissors using 'dir'
      var dir = this.get('dir');
      this._scissorsOverlay.set('x', dir[0]*40);
      this._scissorsOverlay.set('y', dir[1]*40);
      
      this._scissorsOverlay.render( this.get('boundingBox') );
   }
   
};



}, '@VERSION@', {"requires": ["overlay"]});
YUI.add('textarea-container', function (Y, NAME) {

/**
 * @module textarea-container
 */

/**
 * Form container for a single textarea field which is resizeable. 
 * Important: this class takes the exact same arguments as the FormContainer !
 * You still need to specify the "fields".
 * @class TextareaContainer
 * @extends FormContainer
 * @constructor
 * @param {Object}   options  Configuration object (see properties)
 */

Y.TextareaContainer = Y.Base.create("textarea-container", Y.Container, [], {
   
   SERIALIZABLE_ATTRS: Y.Container.prototype.SERIALIZABLE_ATTRS.concat(['value'])
   
   
   /*
   
   this.ddResize.on('eventResize', function (e, args) {
      var el = this.form.inputs[0].el;
      Y.one(el).setStyle("height", (args[0][1]-48)+"px");
      Y.one(el).setStyle(el, "width", (args[0][0]-17)+"px");
   }, this, true);
*/
   
}, {
   
   ATTRS: {
      
      /**
       * Value of the textarea
       * @attribute value
       */
      value: {
         getter: function () {
            return this.getStdModNode(Y.WidgetStdMod.BODY).one('textarea').get('value');
         },
         
         setter: function (value) {
            this.set('bodyContent', '<textarea>'+value+'</textarea>');
         }
      },
      
      /**
       * Keep to render the textarea
       * @attribute bodyContent
       */
      bodyContent: {
         value: '<textarea />'
      }
      
   }
   
});



}, '@VERSION@', {"requires": ["container"]});
YUI.add('widget-icons', function (Y, NAME) {

/**
 * @module widget-icons
 */

/**
 * @class WidgetIcons
 * @constructor
 * @param {Object} config configuration object
 */
Y.WidgetIcons = function (config) {

   Y.after(this._renderUIicons, this, "renderUI");
   
};

Y.WidgetIcons.ATTRS = {
   
   /**
    * Set of icons
    * @attribute icons
    */
   icons: {
      value: []
   }
   
};

Y.WidgetIcons.prototype = {
   
   _renderUIicons: function () {
      
      var p = this.get('contentBox'),
          that= this;
          
      Y.Array.each( this.get('icons'), function (icon) {
         var i = Y.Node.create('<span class="'+that.getClassName('icon')+' '+icon.className+'" title="'+icon.title+'"></span>');
         i.on('click', Y.bind(that[icon.click], that) );
         i.appendTo( p );
         //p.insertBefore(i, p.get('children').item(0) );
      });
      
   }
   
};



}, '@VERSION@', {"requires": [], "skinnable": true});
YUI.add('wire-base', function (Y, NAME) {

/**
 * @module wire-base
 */

/**
 * The wire widget
 * The wire is drawn between "src" and "tgt" (so they might be directional).
 *
 * "src" and "tgt" MUST have a "getXY" function
 *
 * "src" and "tgt" MAY additionnaly have the "addWire", "removeWire" methods.
 * Those methods are designed to be used through the Y.WiringsDelegate extension,
 * which provide basic list-handling on wires.
 *
 * @class WireBase
 * @extends Path
 * @param {Object} oConfigs The user configuration for the instance.
 */
Y.WireBase = function (cfg) {
   Y.WireBase.superclass.constructor.apply(this, arguments);
};

Y.WireBase.NAME = "wirebase";

Y.extend(Y.WireBase, Y.Path, {
   
   /**
    * Notify the WiresDeletates through addWire
    * @method initializer
    */
   initializer: function () {
      
      Y.WireBase.superclass.initializer.apply(this, arguments);
      
      var src = this.get('src'), tgt = this.get('tgt');
      
      if(src && src.get) {
         this.set('srcDir', src.get('dir') );
      }
      
      if(tgt && tgt.get) {
         this.set('tgtDir', tgt.get('dir') );
      }
      
      if(src && Y.Lang.isFunction (src.addWire) ) {
         src.addWire(this);
      }
      if(tgt && Y.Lang.isFunction (tgt.addWire) ) {
         tgt.addWire(this);
      }
      
   },
   
   
   /**
    * @method bindUI
    */
   bindUI: function () {
      Y.ArrowWire.superclass.bindUI.call(this);
      
      //this.after("bezierTangentNormChange", this._afterChangeRedraw, this);
      
      this.on('srcChange', function (e) {
         this.set('srcDir', e.newVal.get('dir') );
      }, this);
      
      this.on('tgtChange', function (e) {
         this.set('tgtDir', e.newVal.get('dir') );
      }, this);
      
   },
   
   
   /**
    * call removeWire on WiringsDelegate
    * @method destroy
    */
   destroy: function () {
      
      Y.WireBase.superclass.destroy.apply(this, arguments);
      
      var src = this.get('src'), tgt = this.get('tgt');
      
      if(src && Y.Lang.isFunction (src.removeWire) ) {
         src.removeWire(this);
      }
      if(tgt && Y.Lang.isFunction (tgt.removeWire) ) {
         tgt.removeWire(this);
      }
   },
   
   /**
    * Drawing method. Meant to be overriden by a plugin
    * @method _draw
    * @private
    */
   _draw: function () {
      //throw new Error("Y.Wire has no draw method. Consider using a plugin such as 'bezier-wire' in your YUI.use statement");
   },
   
   getOtherTerminal: function (term) {
      return (term == this.get('src')) ? this.get('tgt') : this.get('src');
   },
   
   // TODO:
   SERIALIZABLE_ATTRS: ["src","tgt"],
   toJSON: function () {
      return {};
   }
   
});


Y.WireBase.ATTRS = Y.merge(Y.Path.ATTRS, {
   
   /**
    * @attribute src
    */
   src: {
      value: null,
      setter: function (val) {
         //console.log("src setter", val, this);
         
         // remove this wire from the list of the previous src/tgt item
         // TODO: prev value
         /*if(e.prevVal && Y.Lang.isFunction (e.prevVal.removeWire) ) {
            e.prevVal.removeWire(this);
         }*/
         
         if(val && Y.Lang.isFunction (val.addWire) ) {
            val.addWire(this);
         }
         
         return val;
      }
   },
   
   /**
    * @attribute tgt
    */
   tgt: {
      value: null,
      setter: function (val) {
         //console.log("tgt setter", val, this);
         
         
         // remove this wire from the list of the previous src/tgt item
         // TODO: prev value
         /*if(e.prevVal && Y.Lang.isFunction (e.prevVal.removeWire) ) {
            e.prevVal.removeWire(this);
         }*/
         
         
         if(val && Y.Lang.isFunction (val.addWire) ) {
            val.addWire(this);
         }
         
         return val;
      }
   },
   
   /**
    * 
    * @attribute srcDir
    * @type Array
    * @default [1,0]
    */ 
   srcDir: {
      validator: Y.Lang.isArray,
      value: [1,0]
      // TODO: normalize ?
   },
   
   /**
    * TODO: normalize ?
    * @attribute tgtDir
    * @type Array
    * @default -srcDir
    */
   tgtDir: {
      validator: Y.Lang.isArray,
      valueFn: function () {
         var d = this.get('srcDir');
         return [-d[0],-d[1]];
      }
      // TODO: normalize ?
   }
   
});


}, '@VERSION@', {"requires": ["graphics"], "skinnable": true});
YUI.add('wireit-app', function (Y, NAME) {


// -- LocalStorageSync ---------------------------------------------------------------------
// Saves WiringModel
function LocalStorageSync(key) {
    var localStorage;

    if (!key) {
        Y.error('No storage key specified.');
    }

    if (Y.config.win.localStorage) {
        localStorage = Y.config.win.localStorage;
    }

    // Try to retrieve existing data from localStorage, if there is any.
    // Otherwise, initialize `data` to an empty object.
    var data = Y.JSON.parse((localStorage && localStorage.getItem(key)) || '{}');

    // Delete a model with the specified id.
    function destroy(id) {
        var modelHash;

        if ((modelHash = data[id])) {
            delete data[id];
            save();
        }

        return modelHash;
    }

    // Generate a unique id to assign to a newly-created model.
    function generateId() {
        var id = '',
            i  = 4;

        while (i--) {
            id += (((1 + Math.random()) * 0x10000) | 0)
                    .toString(16).substring(1);
        }

        return id;
    }

    // Loads a model with the specified id. This method is a little tricky,
    // since it handles loading for both individual models and for an entire
    // model list.
    //
    // If an id is specified, then it loads a single model. If no id is
    // specified then it loads an array of all models. This allows the same sync
    // layer to be used for both the TodoModel and TodoList classes.
    function get(id) {
        return id ? data[id] : Y.Object.values(data);
    }

    // Saves the entire `data` object to localStorage.
    function save() {
        localStorage && localStorage.setItem(key, Y.JSON.stringify(data));
    }

    // Sets the id attribute of the specified model (generating a new id if
    // necessary), then saves it to localStorage.
    function set(model) {
        var hash        = model.toJSON(),
            idAttribute = model.idAttribute;

        if (!Y.Lang.isValue(hash[idAttribute])) {
            hash[idAttribute] = generateId();
        }

        data[hash[idAttribute]] = hash;
        save();

        return hash;
    }

    // Returns a `sync()` function that can be used with either a Model or a
    // ModelList instance.
    return function (action, options, callback) {
        // `this` refers to the Model or ModelList instance to which this sync
        // method is attached.
        var isModel = Y.Model && this instanceof Y.Model;

        switch (action) {
        case 'create': // intentional fallthru
        case 'update':
            callback(null, set(this));
            return;

        case 'read':
            callback(null, get(isModel && this.get('id')));
            return;

        case 'delete':
            callback(null, destroy(isModel && this.get('id')));
            return;
        }
    };
}


// -- WiringModel ---------------------------------------------------------------------
Y.WiringModel = Y.Base.create('wiringModel', Y.Model, [], {
   sync: LocalStorageSync('wireit-app')
}, {
   ATTRS: {
      id: {value: null},
      name       : {value: ''},
      containers   : {value: []},
      description: {value: ''},
      wires   : {value: []}
   }
});


// -- WiringModelList ---------------------------------------------------------------------

Y.WiringModelList = Y.Base.create('wiringModelList', Y.ModelList, [], {
   sync: LocalStorageSync('wireit-app'),
    model    : Y.WiringModel
});

// -- WiringList View ------------------------------------------------------------

Y.WiringListView = Y.Base.create('wiringListView', Y.View, [], {
   
   template: Y.Handlebars.compile(Y.one('#t-wiring-list').getContent()),
   
   initializer: function () {
      
      //console.log('WiringListView init');
      
      /*var list = this.get('modelList');
      
      // Re-render this view when a model is added to or removed from the model list.
      list.after(['add', 'remove', 'reset'], this._test, this);
      
      // We'll also re-render the view whenever the data of one of the models in the list changes.
      list.after('*:change', this._test, this);*/
   },
   
   /*_test: function () {
      console.log('_test');
   },*/
   
   render: function () {
      
      //console.log('WiringListView render');
      
      var content = this.template({wirings: this.get('modelList').toJSON() });
      this.get('container').setContent(content);
      return this;
   }
});


// -- ContainerType ---------------------------------------------------------------------
Y.ContainerType = Y.Base.create('containerModel', Y.Model, [], {
   // The `id` attribute for this Model will be an alias for `name`.
   idAttribute: 'name'
}, {
   ATTRS: {
      name       : {value: null},
      description: {value: null},
      config   : {value: null}
   }
});

// -- ContainerTypeList -----------------------------------------------------------------
Y.ContainerTypeList = Y.Base.create('containerTypeList', Y.ModelList, [], {
   model: Y.ContainerType
});

// -- Editor View ------------------------------------------------------------
Y.EditorView = Y.Base.create('editorView', Y.View, [], {
   
   template: Y.Handlebars.compile(Y.one('#t-editor').getContent()),
   
   events: {
      '#wiring-save-btn': {click: 'saveWiring'}
   },
   
   render: function () {
      
      var content = this.template({
         containerTypes: this.get('containerTypes').toJSON()
      });
      this.get('container').setContent(content);
      
      
      // Make items draggable to the layer
      var that = this;
      this.get('container').all('.containerType-name').each(function (node) {
         
         var drag = new Y.DD.Drag({ 
            node: node,
            groups: ['containerType']
         }).plug(Y.Plugin.DDProxy, {
            cloneNode: true,
            moveOnEnd: false
         });
         drag._containerTypeName = node._node.attributes["app-container-name"].value; //node._node.innerHTML;
         
         // On drom, add it to the layer
         drag.on('drag:drophit',  function (ev) {
            that._addContainerFromName(ev.drag._containerTypeName, {
               x: ev.drag.lastXY[0],
               y: ev.drag.lastXY[1]
            });
         });
         
         
      });
      
      this._renderLayer();
      
      return this;
   },
   
   _renderLayer: function () {
      
      this.layer = new Y.Layer({
         //width: 900,
         height: 500
      });
      
      // Create the Drop object
      var drop = new Y.DD.Drop({
         node: this.layer.get('contentBox'),
         groups: ['containerType']
      });
      //drop.layer = this.layer;
      
      var wiring = this.get('model');
      if(wiring) {
         this.setWiring( wiring );
      }
      
      this.layer.render( this.get('container').one('#layer-container') );
      
   },
   
   saveWiring: function (e) {
      var o = {
         name: Y.one('#wiring-name').get('value') || 'Unnamed'
      };
      
      // Children are containers
      o.containers = [];
      Y.Array.each(this.layer._items, function (item) {
         o.containers.push({
            containerType: item.containerTypeName,
            config: item.toJSON()
         });
      });
      
      // Wires:
      o.wires = [];
      var layer = this.layer;
      Y.Array.each(this.layer._wires, function (wire) {
         
         var src = wire.get('src');
         var tgt = wire.get('tgt');
         
         o.wires.push( {
            src: { container: layer._items.indexOf( src.get('parent') ), terminal: src.get('name') },
            tgt: { container: layer._items.indexOf( tgt.get('parent') ), terminal: tgt.get('name') },
            config: wire.toJSON()
         });
      });
      
      
      if( this.get('model') ) {
         this.get('model').setAttrs(o);
      }
      else {
         this.set('model', new Y.WiringModel(o) );
      }
      
      this.get('model').save();
      
      // TODO: add only one message
      var s = Y.Node.create('<div class="alert-message bg-warning" style="width: 300px; z-index: 10001;"><p>Saved !</p></div>').appendTo(document.body);
      var anim = new Y.Anim({
          node: s,
          duration: 0.5,
          easing: Y.Easing.easeOut,
         from: { xy: [400, -50] },
         to: { xy: [400, 2] }
      });
      anim.on('end', function () {
         Y.later(1000, this, function () {
            (new Y.Anim({
                node: s,
                duration: 0.5,
                easing: Y.Easing.easeOut,
               to: { xy: [400, -50] }
            })).run();
         });
      });
      anim.run();
      
      
   },
   
   setWiring: function (wiring) {
      
      var that = this;
      
      var layer = this.layer;
      
      Y.Array.each( wiring.get('containers'), function (container) {
         
         that._addContainerFromName(container.containerType,  container.config);
         
         Y.on('available', function (el) {
            Y.one('#wiring-name').set('value', wiring.get('name') );
         }, '#wiring-name');
         
      });
      
      Y.Array.each( wiring.get('wires'), function (wire) {
         
         // prevent bad configs...
         if(!wire.src || !wire.tgt) return;
         
         var srcContainer = layer.item(wire.src.container);
         var srcTerminal = srcContainer.getTerminal(wire.src.terminal);
         
         var tgtContainer = layer.item(wire.tgt.container);
         var tgtTerminal = tgtContainer.getTerminal(wire.tgt.terminal);
         
         // TODO: wire.config;
         
         var w = layer.graphic.addShape({
            type: Y.BezierWire,
            stroke: {
                weight: 4,
                color: "rgb(173,216,230)" 
            },


            src: srcTerminal,
            tgt: tgtTerminal

         });
         
      });
      
      // TODO: this is awful ! But we need to wait for everything to render & position
      Y.later(1000, this, function () {
         layer.redrawAllWires();
      });
      
   },
   
   _addContainerFromName: function (containerTypeName, containerConfig) {
      var containerType = this.get('containerTypes').getById(containerTypeName);
      var containerConf = Y.mix({}, containerType.get('config'));
      containerConf = Y.mix(containerConf, containerConfig);
      this.layer.add(containerConf);
      var container =  this.layer.item(this.layer.size()-1);
      container.containerTypeName = containerTypeName;
   }
   
}, {
   ATTRS: {
      containerTypes: {
         value: null
      }
   }
});
/**
 * @module wireit-app
 */



// -- WireIt App ---------------------------------------------------------
Y.WireItApp = new Y.Base.create('contributorsApp', Y.App, [], {
   
   views: {
      editorPage: {
         type: Y.EditorView
      },
      wiringListPage: {
         type: Y.WiringListView
      }
   },
   
   initializer: function () {
      
      // show indication that the app is busy loading data.
      this.on('navigate', this.indicateLoading);
      
      this.once('ready', function (e) {
         if (this.hasRoute(this.getPath())) {
            this.dispatch();
         } else {
            this.showWiringListPage();
         }
      });
   },
   
   // -- Event Handlers -------------------------------------------------------
   
   indicateLoading: function (e) {
      this.get('activeView').get('container').addClass('loading');
   },
   
   // -- Route Handlers -------------------------------------------------------
   
   handleWiring: function (req, res, next) {
      var wiringId = req.params.wiring,
         wirings = this.get('modelList'),
         wiring = wirings.getById(wiringId);
      
      this.set('wiring', wiring);
      
      next();
   },

   showEditorPage: function () {
      this.showView('editorPage', {
         containerTypes: this.get('containerTypes'),
         wirings: this.get('modelList'),
         model: this.get('wiring')
      });
   },
   
   blankEditorPage: function () {
      this.showView('editorPage', {
         containerTypes: this.get('containerTypes'),
         wirings: this.get('modelList'),
         model: null
      });
   },
   
   showWiringListPage: function () {
      
      //this.get('modelList').load();
      
      var wirings = new Y.WiringModelList();
      wirings.load();
      this.set('modelList', wirings);
      
      this.showView('wiringListPage', {
         modelList: this.get('modelList')
      });
   }

}, {
   ATTRS: {
      
      containerTypes: {
         value: new Y.ContainerTypeList()
      },
      
      modelList: {
         value: new Y.WiringModelList()
      },
      
      wiring: {
         value: null
      },
      
      routes: {
         value: [
            {path: '/', callback: 'showWiringListPage'},
            {path: '/wirings/:wiring/*', callback: 'handleWiring'},
            {path: '/wirings/:wiring/edit', callback: 'showEditorPage'},
            {path: '/wirings/new', callback: 'blankEditorPage'}
         ]
      }
   }
});



}, '@VERSION@', {"requires": ["app", "handlebars", "model", "model-list", "json", "view", "layer", "bezier-wire", "anim"]});
YUI.add('wires-delegate', function (Y, NAME) {

/**
 * @module wires-delegate
 */

/**
 * WiresDelegate is an extension for Widgets to manipulate a list of wires.
 *
 * The WidgetParent/WidgetChild relationship isn't sufficient
 * because wires have 2 parents, so we use this extension instead of WidgetParent
 *
 * @class WiresDelegate
 * @constructor
 * @param {Object} config configuration object
 */
Y.WiresDelegate = function (config) {
   
   this._wires = [];
   
   this.publish('addWire');
   
   this.publish('removeWire');
   
   // Bubble events from terminals
   this.on('terminal:addWire', this._onAddWire, this);
   this.on('terminal:removeWire', this._onRemoveWire, this);
   
};

Y.WiresDelegate.ATTRS = {};

Y.WiresDelegate.prototype = {
   
   _onAddWire: function (e) {
      var w = e;
      while(!!w._event) { w = w.details[0]; }
      this.addWire(w);
   },
   
   _onRemoveWire: function (e) {
      var w = e;
      while(!!w._event) { w = w.details[0]; }
      this.removeWire(w);
   },
   
   /**
    * Add a wire to this terminal.
    * @method addWire
    * @param {Wire} wire Wire instance to add
    */
   addWire: function (wire) {
      var index = Y.Array.indexOf(this._wires, wire); 
      if(index == -1) {
         this._wires.push(wire);
         this.fire('addWire', wire);
      }
   },
   
   /**
    * When a wire is destroyed
    * @method removeWire
    */
   removeWire: function (wire) {
      
      var index = Y.Array.indexOf(this._wires, wire); 
      
      if( index != -1 ) {
         
         // Compact the array
         var w = this._wires;
         this._wires = [];
         var v = this._wires;
         Y.Array.each(w,function (i) { if(i != wire){ v.push(i); } });
         
         // Fire the event
         this.fire('removeWire', wire);
      }
      
   },
   
   /** 
    * Remove all wires
    * @method destroyWires
    */
   destroyWires: function () {
      
      if(this._wires) {
         Y.Array.each(this._wires, function (w) {
            w.destroy();
         });
      }
   
   },
   
   /**
    * Returns a list of all the terminals connected to this terminal through its wires.
    * @method getConnected
    * @return  {Array}  List of all connected terminals
    */
   getConnected: function () {
      var list = [];
      if(this._wires) {
         for(var i = 0, n = this._wires.length ; i < n ; i++) {
            list.push(this._wires[i].getOtherTerminal(this));
         }
      }
      return list;
   },
   
   /**
    * Redraw all the wires connected to this terminal
    * @method redrawAllWires
    */
   redrawAllWires: function () {
      
      if(this._wires) {
         Y.Array.each(this._wires, function (w) {
            w._draw();
         });
      }
   },

   destructor: function () {
      this.destroyWires();
   }
   
};



}, '@VERSION@', {"requires": ["wire-base"]});
YUI.add('wireit-all', function (Y, NAME) {}, '@VERSION@', {"skinnable": true});
