<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src&#x2F;excanvas&#x2F;excanvas.js - WireIt</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.5.1&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/favicon.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.5.1&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="..&#x2F;assets/css/logo.png" title="WireIt"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 3.0.0pr1</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="..&#x2F;classes/BaseField.html">BaseField</a></li>
            
                <li><a href="..&#x2F;classes/BezierWire.html">BezierWire</a></li>
            
                <li><a href="..&#x2F;classes/CanvasNode.html">CanvasNode</a></li>
            
                <li><a href="..&#x2F;classes/CanvasWire.html">CanvasWire</a></li>
            
                <li><a href="..&#x2F;classes/Container.html">Container</a></li>
            
                <li><a href="..&#x2F;classes/ContainerBase.html">ContainerBase</a></li>
            
                <li><a href="..&#x2F;classes/Field.html">Field</a></li>
            
                <li><a href="..&#x2F;classes/FormContainer.html">FormContainer</a></li>
            
                <li><a href="..&#x2F;classes/ImageContainer.html">ImageContainer</a></li>
            
                <li><a href="..&#x2F;classes/InOutContainer.html">InOutContainer</a></li>
            
                <li><a href="..&#x2F;classes/Layer.html">Layer</a></li>
            
                <li><a href="..&#x2F;classes/Terminal.html">Terminal</a></li>
            
                <li><a href="..&#x2F;classes/TerminalBase.html">TerminalBase</a></li>
            
                <li><a href="..&#x2F;classes/TerminalDDGroups.html">TerminalDDGroups</a></li>
            
                <li><a href="..&#x2F;classes/TerminalDragEdit.html">TerminalDragEdit</a></li>
            
                <li><a href="..&#x2F;classes/TerminalInput.html">TerminalInput</a></li>
            
                <li><a href="..&#x2F;classes/TerminalOutput.html">TerminalOutput</a></li>
            
                <li><a href="..&#x2F;classes/TerminalScissors.html">TerminalScissors</a></li>
            
                <li><a href="..&#x2F;classes/WidgetIcons.html">WidgetIcons</a></li>
            
                <li><a href="..&#x2F;classes/WireBase.html">WireBase</a></li>
            
                <li><a href="..&#x2F;classes/WiresDelegate.html">WiresDelegate</a></li>
            
                <li><a href="..&#x2F;classes/Y.WireTextareaContainer.html">Y.WireTextareaContainer</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="..&#x2F;modules/bezier-wire.html">bezier-wire</a></li>
            
                <li><a href="..&#x2F;modules/canvas-node.html">canvas-node</a></li>
            
                <li><a href="..&#x2F;modules/canvas-wire.html">canvas-wire</a></li>
            
                <li><a href="..&#x2F;modules/container.html">container</a></li>
            
                <li><a href="..&#x2F;modules/container-base.html">container-base</a></li>
            
                <li><a href="..&#x2F;modules/form-container.html">form-container</a></li>
            
                <li><a href="..&#x2F;modules/image-container.html">image-container</a></li>
            
                <li><a href="..&#x2F;modules/inout-container.html">inout-container</a></li>
            
                <li><a href="..&#x2F;modules/layer.html">layer</a></li>
            
                <li><a href="..&#x2F;modules/straight-wire.html">straight-wire</a></li>
            
                <li><a href="..&#x2F;modules/terminal.html">terminal</a></li>
            
                <li><a href="..&#x2F;modules/terminal-base.html">terminal-base</a></li>
            
                <li><a href="..&#x2F;modules/terminal-ddgroups.html">terminal-ddgroups</a></li>
            
                <li><a href="..&#x2F;modules/terminal-dragedit.html">terminal-dragedit</a></li>
            
                <li><a href="..&#x2F;modules/terminal-input.html">terminal-input</a></li>
            
                <li><a href="..&#x2F;modules/terminal-output.html">terminal-output</a></li>
            
                <li><a href="..&#x2F;modules/terminal-scissors.html">terminal-scissors</a></li>
            
                <li><a href="..&#x2F;modules/textarea-container.html">textarea-container</a></li>
            
                <li><a href="..&#x2F;modules/widget-icons.html">widget-icons</a></li>
            
                <li><a href="..&#x2F;modules/wire-base.html">wire-base</a></li>
            
                <li><a href="..&#x2F;modules/wireit-app.html">wireit-app</a></li>
            
                <li><a href="..&#x2F;modules/wires-delegate.html">wires-delegate</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: src&#x2F;excanvas&#x2F;excanvas.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x2F;&#x2F; Copyright 2006 Google Inc.
&#x2F;&#x2F;
&#x2F;&#x2F; Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&#x2F;&#x2F; you may not use this file except in compliance with the License.
&#x2F;&#x2F; You may obtain a copy of the License at
&#x2F;&#x2F;
&#x2F;&#x2F;   http:&#x2F;&#x2F;www.apache.org&#x2F;licenses&#x2F;LICENSE-2.0
&#x2F;&#x2F;
&#x2F;&#x2F; Unless required by applicable law or agreed to in writing, software
&#x2F;&#x2F; distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&#x2F;&#x2F; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&#x2F;&#x2F; See the License for the specific language governing permissions and
&#x2F;&#x2F; limitations under the License.


&#x2F;&#x2F; Known Issues:
&#x2F;&#x2F;
&#x2F;&#x2F; * Patterns are not implemented.
&#x2F;&#x2F; * Radial gradient are not implemented. The VML version of these look very
&#x2F;&#x2F;   different from the canvas one.
&#x2F;&#x2F; * Clipping paths are not implemented.
&#x2F;&#x2F; * Coordsize. The width and height attribute have higher priority than the
&#x2F;&#x2F;   width and height style values which isn&#x27;t correct.
&#x2F;&#x2F; * Painting mode isn&#x27;t implemented.
&#x2F;&#x2F; * Canvas width&#x2F;height should is using content-box by default. IE in
&#x2F;&#x2F;   Quirks mode will draw the canvas using border-box. Either change your
&#x2F;&#x2F;   doctype to HTML5
&#x2F;&#x2F;   (http:&#x2F;&#x2F;www.whatwg.org&#x2F;specs&#x2F;web-apps&#x2F;current-work&#x2F;#the-doctype)
&#x2F;&#x2F;   or use Box Sizing Behavior from WebFX
&#x2F;&#x2F;   (http:&#x2F;&#x2F;webfx.eae.net&#x2F;dhtml&#x2F;boxsizing&#x2F;boxsizing.html)
&#x2F;&#x2F; * Non uniform scaling does not correctly scale strokes.
&#x2F;&#x2F; * Optimize. There is always room for speed improvements.

&#x2F;&#x2F; Only add this code if we do not already have a canvas implementation
if (!document.createElement(&#x27;canvas&#x27;).getContext) {

(function() {

  &#x2F;&#x2F; alias some functions to make (compiled) code shorter
  var m = Math;
  var mr = m.round;
  var ms = m.sin;
  var mc = m.cos;
  var abs = m.abs;
  var sqrt = m.sqrt;

  &#x2F;&#x2F; this is used for sub pixel precision
  var Z = 10;
  var Z2 = Z &#x2F; 2;

  &#x2F;**
   * This funtion is assigned to the &lt;canvas&gt; elements as element.getContext().
   * @this {HTMLElement}
   * @return {CanvasRenderingContext2D_}
   *&#x2F;
  function getContext() {
    return this.context_ ||
        (this.context_ = new CanvasRenderingContext2D_(this));
  }

  var slice = Array.prototype.slice;

  &#x2F;**
   * Binds a function to an object. The returned function will always use the
   * passed in {@code obj} as {@code this}.
   *
   * Example:
   *
   *   g = bind(f, obj, a, b)
   *   g(c, d) &#x2F;&#x2F; will do f.call(obj, a, b, c, d)
   *
   * @param {Function} f The function to bind the object to
   * @param {Object} obj The object that should act as this when the function
   *     is called
   * @param {*} var_args Rest arguments that will be used as the initial
   *     arguments when the function is called
   * @return {Function} A new function that has bound this
   *&#x2F;
  function bind(f, obj, var_args) {
    var a = slice.call(arguments, 2);
    return function() {
      return f.apply(obj, a.concat(slice.call(arguments)));
    };
  }

  var G_vmlCanvasManager_ = {
    init: function(opt_doc) {
      if (&#x2F;MSIE&#x2F;.test(navigator.userAgent) &amp;&amp; !window.opera) {
        var doc = opt_doc || document;
        &#x2F;&#x2F; Create a dummy element so that IE will allow canvas elements to be
        &#x2F;&#x2F; recognized.
        doc.createElement(&#x27;canvas&#x27;);
        doc.attachEvent(&#x27;onreadystatechange&#x27;, bind(this.init_, this, doc));
      }
    },

    init_: function(doc) {
      &#x2F;&#x2F; create xmlns
      if (!doc.namespaces[&#x27;g_vml_&#x27;]) {
        doc.namespaces.add(&#x27;g_vml_&#x27;, &#x27;urn:schemas-microsoft-com:vml&#x27;,
                           &#x27;#default#VML&#x27;);

      }
      if (!doc.namespaces[&#x27;g_o_&#x27;]) {
        doc.namespaces.add(&#x27;g_o_&#x27;, &#x27;urn:schemas-microsoft-com:office:office&#x27;,
                           &#x27;#default#VML&#x27;);
      }

      &#x2F;&#x2F; Setup default CSS.  Only add one style sheet per document
      if (!doc.styleSheets[&#x27;ex_canvas_&#x27;]) {
        var ss = doc.createStyleSheet();
        ss.owningElement.id = &#x27;ex_canvas_&#x27;;
        ss.cssText = &#x27;canvas{display:inline-block;overflow:hidden;&#x27; +
            &#x2F;&#x2F; default size is 300x150 in Gecko and Opera
            &#x27;text-align:left;width:300px;height:150px}&#x27; +
            &#x27;g_vml_\\:*{behavior:url(#default#VML)}&#x27; +
            &#x27;g_o_\\:*{behavior:url(#default#VML)}&#x27;;

      }

      &#x2F;&#x2F; find all canvas elements
      var els = doc.getElementsByTagName(&#x27;canvas&#x27;);
      for (var i = 0; i &lt; els.length; i++) {
        this.initElement(els[i]);
      }
    },

    &#x2F;**
     * Public initializes a canvas element so that it can be used as canvas
     * element from now on. This is called automatically before the page is
     * loaded but if you are creating elements using createElement you need to
     * make sure this is called on the element.
     * @param {HTMLElement} el The canvas element to initialize.
     * @return {HTMLElement} the element that was created.
     *&#x2F;
    initElement: function(el) {
      if (!el.getContext) {

        el.getContext = getContext;

        &#x2F;&#x2F; Remove fallback content. There is no way to hide text nodes so we
        &#x2F;&#x2F; just remove all childNodes. We could hide all elements and remove
        &#x2F;&#x2F; text nodes but who really cares about the fallback content.
        el.innerHTML = &#x27;&#x27;;

        &#x2F;&#x2F; do not use inline function because that will leak memory
        el.attachEvent(&#x27;onpropertychange&#x27;, onPropertyChange);
        el.attachEvent(&#x27;onresize&#x27;, onResize);

        var attrs = el.attributes;
        if (attrs.width &amp;&amp; attrs.width.specified) {
          &#x2F;&#x2F; TODO: use runtimeStyle and coordsize
          &#x2F;&#x2F; el.getContext().setWidth_(attrs.width.nodeValue);
          el.style.width = attrs.width.nodeValue + &#x27;px&#x27;;
        } else {
          el.width = el.clientWidth;
        }
        if (attrs.height &amp;&amp; attrs.height.specified) {
          &#x2F;&#x2F; TODO: use runtimeStyle and coordsize
          &#x2F;&#x2F; el.getContext().setHeight_(attrs.height.nodeValue);
          el.style.height = attrs.height.nodeValue + &#x27;px&#x27;;
        } else {
          el.height = el.clientHeight;
        }
        &#x2F;&#x2F;el.getContext().setCoordsize_()
      }
      return el;
    }
  };

  function onPropertyChange(e) {
    var el = e.srcElement;

    switch (e.propertyName) {
      case &#x27;width&#x27;:
        el.style.width = el.attributes.width.nodeValue + &#x27;px&#x27;;
        el.getContext().clearRect();
        break;
      case &#x27;height&#x27;:
        el.style.height = el.attributes.height.nodeValue + &#x27;px&#x27;;
        el.getContext().clearRect();
        break;
    }
  }

  function onResize(e) {
    var el = e.srcElement;
    if (el.firstChild) {
      el.firstChild.style.width =  el.clientWidth + &#x27;px&#x27;;
      el.firstChild.style.height = el.clientHeight + &#x27;px&#x27;;
    }
  }

  G_vmlCanvasManager_.init();

  &#x2F;&#x2F; precompute &quot;00&quot; to &quot;FF&quot;
  var dec2hex = [];
  for (var i = 0; i &lt; 16; i++) {
    for (var j = 0; j &lt; 16; j++) {
      dec2hex[i * 16 + j] = i.toString(16) + j.toString(16);
    }
  }

  function createMatrixIdentity() {
    return [
      [1, 0, 0],
      [0, 1, 0],
      [0, 0, 1]
    ];
  }

  function matrixMultiply(m1, m2) {
    var result = createMatrixIdentity();

    for (var x = 0; x &lt; 3; x++) {
      for (var y = 0; y &lt; 3; y++) {
        var sum = 0;

        for (var z = 0; z &lt; 3; z++) {
          sum += m1[x][z] * m2[z][y];
        }

        result[x][y] = sum;
      }
    }
    return result;
  }

  function copyState(o1, o2) {
    o2.fillStyle     = o1.fillStyle;
    o2.lineCap       = o1.lineCap;
    o2.lineJoin      = o1.lineJoin;
    o2.lineWidth     = o1.lineWidth;
    o2.miterLimit    = o1.miterLimit;
    o2.shadowBlur    = o1.shadowBlur;
    o2.shadowColor   = o1.shadowColor;
    o2.shadowOffsetX = o1.shadowOffsetX;
    o2.shadowOffsetY = o1.shadowOffsetY;
    o2.strokeStyle   = o1.strokeStyle;
    o2.globalAlpha   = o1.globalAlpha;
    o2.arcScaleX_    = o1.arcScaleX_;
    o2.arcScaleY_    = o1.arcScaleY_;
    o2.lineScale_    = o1.lineScale_;
  }

  function processStyle(styleString) {
    var str, alpha = 1;

    styleString = String(styleString);
    if (styleString.substring(0, 3) == &#x27;rgb&#x27;) {
      var start = styleString.indexOf(&#x27;(&#x27;, 3);
      var end = styleString.indexOf(&#x27;)&#x27;, start + 1);
      var guts = styleString.substring(start + 1, end).split(&#x27;,&#x27;);

      str = &#x27;#&#x27;;
      for (var i = 0; i &lt; 3; i++) {
        str += dec2hex[Number(guts[i])];
      }

      if (guts.length == 4 &amp;&amp; styleString.substr(3, 1) == &#x27;a&#x27;) {
        alpha = guts[3];
      }
    } else {
      str = styleString;
    }

    return {color: str, alpha: alpha};
  }

  function processLineCap(lineCap) {
    switch (lineCap) {
      case &#x27;butt&#x27;:
        return &#x27;flat&#x27;;
      case &#x27;round&#x27;:
        return &#x27;round&#x27;;
      case &#x27;square&#x27;:
      default:
        return &#x27;square&#x27;;
    }
  }

  &#x2F;**
   * This class implements CanvasRenderingContext2D interface as described by
   * the WHATWG.
   * @param {HTMLElement} surfaceElement The element that the 2D context should
   * be associated with
   *&#x2F;
  function CanvasRenderingContext2D_(surfaceElement) {
    this.m_ = createMatrixIdentity();

    this.mStack_ = [];
    this.aStack_ = [];
    this.currentPath_ = [];

    &#x2F;&#x2F; Canvas context properties
    this.strokeStyle = &#x27;#000&#x27;;
    this.fillStyle = &#x27;#000&#x27;;

    this.lineWidth = 1;
    this.lineJoin = &#x27;miter&#x27;;
    this.lineCap = &#x27;butt&#x27;;
    this.miterLimit = Z * 1;
    this.globalAlpha = 1;
    this.canvas = surfaceElement;

    var el = surfaceElement.ownerDocument.createElement(&#x27;div&#x27;);
    el.style.width =  surfaceElement.clientWidth + &#x27;px&#x27;;
    el.style.height = surfaceElement.clientHeight + &#x27;px&#x27;;
    el.style.overflow = &#x27;hidden&#x27;;
    el.style.position = &#x27;absolute&#x27;;
    surfaceElement.appendChild(el);

    this.element_ = el;
    this.arcScaleX_ = 1;
    this.arcScaleY_ = 1;
    this.lineScale_ = 1;
  }

  var contextPrototype = CanvasRenderingContext2D_.prototype;
  contextPrototype.clearRect = function() {
    this.element_.innerHTML = &#x27;&#x27;;
  };

  contextPrototype.beginPath = function() {
    &#x2F;&#x2F; TODO: Branch current matrix so that save&#x2F;restore has no effect
    &#x2F;&#x2F;       as per safari docs.
    this.currentPath_ = [];
  };

  contextPrototype.moveTo = function(aX, aY) {
    var p = this.getCoords_(aX, aY);
    this.currentPath_.push({type: &#x27;moveTo&#x27;, x: p.x, y: p.y});
    this.currentX_ = p.x;
    this.currentY_ = p.y;
  };

  contextPrototype.lineTo = function(aX, aY) {
    var p = this.getCoords_(aX, aY);
    this.currentPath_.push({type: &#x27;lineTo&#x27;, x: p.x, y: p.y});

    this.currentX_ = p.x;
    this.currentY_ = p.y;
  };

  contextPrototype.bezierCurveTo = function(aCP1x, aCP1y,
                                            aCP2x, aCP2y,
                                            aX, aY) {
    var p = this.getCoords_(aX, aY);
    var cp1 = this.getCoords_(aCP1x, aCP1y);
    var cp2 = this.getCoords_(aCP2x, aCP2y);
    bezierCurveTo(this, cp1, cp2, p);
  };

  &#x2F;&#x2F; Helper function that takes the already fixed cordinates.
  function bezierCurveTo(self, cp1, cp2, p) {
    self.currentPath_.push({
      type: &#x27;bezierCurveTo&#x27;,
      cp1x: cp1.x,
      cp1y: cp1.y,
      cp2x: cp2.x,
      cp2y: cp2.y,
      x: p.x,
      y: p.y
    });
    self.currentX_ = p.x;
    self.currentY_ = p.y;
  }

  contextPrototype.quadraticCurveTo = function(aCPx, aCPy, aX, aY) {
    &#x2F;&#x2F; the following is lifted almost directly from
    &#x2F;&#x2F; http:&#x2F;&#x2F;developer.mozilla.org&#x2F;en&#x2F;docs&#x2F;Canvas_tutorial:Drawing_shapes

    var cp = this.getCoords_(aCPx, aCPy);
    var p = this.getCoords_(aX, aY);

    var cp1 = {
      x: this.currentX_ + 2.0 &#x2F; 3.0 * (cp.x - this.currentX_),
      y: this.currentY_ + 2.0 &#x2F; 3.0 * (cp.y - this.currentY_)
    };
    var cp2 = {
      x: cp1.x + (p.x - this.currentX_) &#x2F; 3.0,
      y: cp1.y + (p.y - this.currentY_) &#x2F; 3.0
    };

    bezierCurveTo(this, cp1, cp2, p);
  };

  contextPrototype.arc = function(aX, aY, aRadius,
                                  aStartAngle, aEndAngle, aClockwise) {
    aRadius *= Z;
    var arcType = aClockwise ? &#x27;at&#x27; : &#x27;wa&#x27;;

    var xStart = aX + mc(aStartAngle) * aRadius - Z2;
    var yStart = aY + ms(aStartAngle) * aRadius - Z2;

    var xEnd = aX + mc(aEndAngle) * aRadius - Z2;
    var yEnd = aY + ms(aEndAngle) * aRadius - Z2;

    &#x2F;&#x2F; IE won&#x27;t render arches drawn counter clockwise if xStart == xEnd.
    if (xStart == xEnd &amp;&amp; !aClockwise) {
      xStart += 0.125; &#x2F;&#x2F; Offset xStart by 1&#x2F;80 of a pixel. Use something
                       &#x2F;&#x2F; that can be represented in binary
    }

    var p = this.getCoords_(aX, aY);
    var pStart = this.getCoords_(xStart, yStart);
    var pEnd = this.getCoords_(xEnd, yEnd);

    this.currentPath_.push({type: arcType,
                           x: p.x,
                           y: p.y,
                           radius: aRadius,
                           xStart: pStart.x,
                           yStart: pStart.y,
                           xEnd: pEnd.x,
                           yEnd: pEnd.y});

  };

  contextPrototype.rect = function(aX, aY, aWidth, aHeight) {
    this.moveTo(aX, aY);
    this.lineTo(aX + aWidth, aY);
    this.lineTo(aX + aWidth, aY + aHeight);
    this.lineTo(aX, aY + aHeight);
    this.closePath();
  };

  contextPrototype.strokeRect = function(aX, aY, aWidth, aHeight) {
    var oldPath = this.currentPath_;
    this.beginPath();

    this.moveTo(aX, aY);
    this.lineTo(aX + aWidth, aY);
    this.lineTo(aX + aWidth, aY + aHeight);
    this.lineTo(aX, aY + aHeight);
    this.closePath();
    this.stroke();

    this.currentPath_ = oldPath;
  };

  contextPrototype.fillRect = function(aX, aY, aWidth, aHeight) {
    var oldPath = this.currentPath_;
    this.beginPath();

    this.moveTo(aX, aY);
    this.lineTo(aX + aWidth, aY);
    this.lineTo(aX + aWidth, aY + aHeight);
    this.lineTo(aX, aY + aHeight);
    this.closePath();
    this.fill();

    this.currentPath_ = oldPath;
  };

  contextPrototype.createLinearGradient = function(aX0, aY0, aX1, aY1) {
    var gradient = new CanvasGradient_(&#x27;gradient&#x27;);
    gradient.x0_ = aX0;
    gradient.y0_ = aY0;
    gradient.x1_ = aX1;
    gradient.y1_ = aY1;
    return gradient;
  };

  contextPrototype.createRadialGradient = function(aX0, aY0, aR0,
                                                   aX1, aY1, aR1) {
    var gradient = new CanvasGradient_(&#x27;gradientradial&#x27;);
    gradient.x0_ = aX0;
    gradient.y0_ = aY0;
    gradient.r0_ = aR0;
    gradient.x1_ = aX1;
    gradient.y1_ = aY1;
    gradient.r1_ = aR1;
    return gradient;
  };

  contextPrototype.drawImage = function(image, var_args) {
    var dx, dy, dw, dh, sx, sy, sw, sh;

    &#x2F;&#x2F; to find the original width we overide the width and height
    var oldRuntimeWidth = image.runtimeStyle.width;
    var oldRuntimeHeight = image.runtimeStyle.height;
    image.runtimeStyle.width = &#x27;auto&#x27;;
    image.runtimeStyle.height = &#x27;auto&#x27;;

    &#x2F;&#x2F; get the original size
    var w = image.width;
    var h = image.height;

    &#x2F;&#x2F; and remove overides
    image.runtimeStyle.width = oldRuntimeWidth;
    image.runtimeStyle.height = oldRuntimeHeight;

    if (arguments.length == 3) {
      dx = arguments[1];
      dy = arguments[2];
      sx = sy = 0;
      sw = dw = w;
      sh = dh = h;
    } else if (arguments.length == 5) {
      dx = arguments[1];
      dy = arguments[2];
      dw = arguments[3];
      dh = arguments[4];
      sx = sy = 0;
      sw = w;
      sh = h;
    } else if (arguments.length == 9) {
      sx = arguments[1];
      sy = arguments[2];
      sw = arguments[3];
      sh = arguments[4];
      dx = arguments[5];
      dy = arguments[6];
      dw = arguments[7];
      dh = arguments[8];
    } else {
      throw Error(&#x27;Invalid number of arguments&#x27;);
    }

    var d = this.getCoords_(dx, dy);

    var w2 = sw &#x2F; 2;
    var h2 = sh &#x2F; 2;

    var vmlStr = [];

    var W = 10;
    var H = 10;

    &#x2F;&#x2F; For some reason that I&#x27;ve now forgotten, using divs didn&#x27;t work
    vmlStr.push(&#x27; &lt;g_vml_:group&#x27;,
                &#x27; coordsize=&quot;&#x27;, Z * W, &#x27;,&#x27;, Z * H, &#x27;&quot;&#x27;,
                &#x27; coordorigin=&quot;0,0&quot;&#x27; ,
                &#x27; style=&quot;width:&#x27;, W, &#x27;px;height:&#x27;, H, &#x27;px;position:absolute;&#x27;);

    &#x2F;&#x2F; If filters are necessary (rotation exists), create them
    &#x2F;&#x2F; filters are bog-slow, so only create them if abbsolutely necessary
    &#x2F;&#x2F; The following check doesn&#x27;t account for skews (which don&#x27;t exist
    &#x2F;&#x2F; in the canvas spec (yet) anyway.

    if (this.m_[0][0] != 1 || this.m_[0][1]) {
      var filter = [];

      &#x2F;&#x2F; Note the 12&#x2F;21 reversal
      filter.push(&#x27;M11=&#x27;, this.m_[0][0], &#x27;,&#x27;,
                  &#x27;M12=&#x27;, this.m_[1][0], &#x27;,&#x27;,
                  &#x27;M21=&#x27;, this.m_[0][1], &#x27;,&#x27;,
                  &#x27;M22=&#x27;, this.m_[1][1], &#x27;,&#x27;,
                  &#x27;Dx=&#x27;, mr(d.x &#x2F; Z), &#x27;,&#x27;,
                  &#x27;Dy=&#x27;, mr(d.y &#x2F; Z), &#x27;&#x27;);

      &#x2F;&#x2F; Bounding box calculation (need to minimize displayed area so that
      &#x2F;&#x2F; filters don&#x27;t waste time on unused pixels.
      var max = d;
      var c2 = this.getCoords_(dx + dw, dy);
      var c3 = this.getCoords_(dx, dy + dh);
      var c4 = this.getCoords_(dx + dw, dy + dh);

      max.x = m.max(max.x, c2.x, c3.x, c4.x);
      max.y = m.max(max.y, c2.y, c3.y, c4.y);

      vmlStr.push(&#x27;padding:0 &#x27;, mr(max.x &#x2F; Z), &#x27;px &#x27;, mr(max.y &#x2F; Z),
                  &#x27;px 0;filter:progid:DXImageTransform.Microsoft.Matrix(&#x27;,
                  filter.join(&#x27;&#x27;), &quot;, sizingmethod=&#x27;clip&#x27;);&quot;)
    } else {
      vmlStr.push(&#x27;top:&#x27;, mr(d.y &#x2F; Z), &#x27;px;left:&#x27;, mr(d.x &#x2F; Z), &#x27;px;&#x27;);
    }

    vmlStr.push(&#x27; &quot;&gt;&#x27; ,
                &#x27;&lt;g_vml_:image src=&quot;&#x27;, image.src, &#x27;&quot;&#x27;,
                &#x27; style=&quot;width:&#x27;, Z * dw, &#x27;px;&#x27;,
                &#x27; height:&#x27;, Z * dh, &#x27;px;&quot;&#x27;,
                &#x27; cropleft=&quot;&#x27;, sx &#x2F; w, &#x27;&quot;&#x27;,
                &#x27; croptop=&quot;&#x27;, sy &#x2F; h, &#x27;&quot;&#x27;,
                &#x27; cropright=&quot;&#x27;, (w - sx - sw) &#x2F; w, &#x27;&quot;&#x27;,
                &#x27; cropbottom=&quot;&#x27;, (h - sy - sh) &#x2F; h, &#x27;&quot;&#x27;,
                &#x27; &#x2F;&gt;&#x27;,
                &#x27;&lt;&#x2F;g_vml_:group&gt;&#x27;);

    this.element_.insertAdjacentHTML(&#x27;BeforeEnd&#x27;,
                                    vmlStr.join(&#x27;&#x27;));
  };

  contextPrototype.stroke = function(aFill) {
    var lineStr = [];
    var lineOpen = false;
    var a = processStyle(aFill ? this.fillStyle : this.strokeStyle);
    var color = a.color;
    var opacity = a.alpha * this.globalAlpha;

    var W = 10;
    var H = 10;

    lineStr.push(&#x27;&lt;g_vml_:shape&#x27;,
                 &#x27; filled=&quot;&#x27;, !!aFill, &#x27;&quot;&#x27;,
                 &#x27; style=&quot;position:absolute;width:&#x27;, W, &#x27;px;height:&#x27;, H, &#x27;px;&quot;&#x27;,
                 &#x27; coordorigin=&quot;0 0&quot; coordsize=&quot;&#x27;, Z * W, &#x27; &#x27;, Z * H, &#x27;&quot;&#x27;,
                 &#x27; stroked=&quot;&#x27;, !aFill, &#x27;&quot;&#x27;,
                 &#x27; path=&quot;&#x27;);

    var newSeq = false;
    var min = {x: null, y: null};
    var max = {x: null, y: null};

    for (var i = 0; i &lt; this.currentPath_.length; i++) {
      var p = this.currentPath_[i];
      var c;

      switch (p.type) {
        case &#x27;moveTo&#x27;:
          c = p;
          lineStr.push(&#x27; m &#x27;, mr(p.x), &#x27;,&#x27;, mr(p.y));
          break;
        case &#x27;lineTo&#x27;:
          lineStr.push(&#x27; l &#x27;, mr(p.x), &#x27;,&#x27;, mr(p.y));
          break;
        case &#x27;close&#x27;:
          lineStr.push(&#x27; x &#x27;);
          p = null;
          break;
        case &#x27;bezierCurveTo&#x27;:
          lineStr.push(&#x27; c &#x27;,
                       mr(p.cp1x), &#x27;,&#x27;, mr(p.cp1y), &#x27;,&#x27;,
                       mr(p.cp2x), &#x27;,&#x27;, mr(p.cp2y), &#x27;,&#x27;,
                       mr(p.x), &#x27;,&#x27;, mr(p.y));
          break;
        case &#x27;at&#x27;:
        case &#x27;wa&#x27;:
          lineStr.push(&#x27; &#x27;, p.type, &#x27; &#x27;,
                       mr(p.x - this.arcScaleX_ * p.radius), &#x27;,&#x27;,
                       mr(p.y - this.arcScaleY_ * p.radius), &#x27; &#x27;,
                       mr(p.x + this.arcScaleX_ * p.radius), &#x27;,&#x27;,
                       mr(p.y + this.arcScaleY_ * p.radius), &#x27; &#x27;,
                       mr(p.xStart), &#x27;,&#x27;, mr(p.yStart), &#x27; &#x27;,
                       mr(p.xEnd), &#x27;,&#x27;, mr(p.yEnd));
          break;
      }


      &#x2F;&#x2F; TODO: Following is broken for curves due to
      &#x2F;&#x2F;       move to proper paths.

      &#x2F;&#x2F; Figure out dimensions so we can do gradient fills
      &#x2F;&#x2F; properly
      if (p) {
        if (min.x == null || p.x &lt; min.x) {
          min.x = p.x;
        }
        if (max.x == null || p.x &gt; max.x) {
          max.x = p.x;
        }
        if (min.y == null || p.y &lt; min.y) {
          min.y = p.y;
        }
        if (max.y == null || p.y &gt; max.y) {
          max.y = p.y;
        }
      }
    }
    lineStr.push(&#x27; &quot;&gt;&#x27;);

    if (!aFill) {
      var lineWidth = this.lineScale_ * this.lineWidth;

      &#x2F;&#x2F; VML cannot correctly render a line if the width is less than 1px.
      &#x2F;&#x2F; In that case, we dilute the color to make the line look thinner.
      if (lineWidth &lt; 1) {
        opacity *= lineWidth;
      }

      lineStr.push(
        &#x27;&lt;g_vml_:stroke&#x27;,
        &#x27; opacity=&quot;&#x27;, opacity, &#x27;&quot;&#x27;,
        &#x27; joinstyle=&quot;&#x27;, this.lineJoin, &#x27;&quot;&#x27;,
        &#x27; miterlimit=&quot;&#x27;, this.miterLimit, &#x27;&quot;&#x27;,
        &#x27; endcap=&quot;&#x27;, processLineCap(this.lineCap), &#x27;&quot;&#x27;,
        &#x27; weight=&quot;&#x27;, lineWidth, &#x27;px&quot;&#x27;,
        &#x27; color=&quot;&#x27;, color, &#x27;&quot; &#x2F;&gt;&#x27;
      );
    } else if (typeof this.fillStyle == &#x27;object&#x27;) {
      var fillStyle = this.fillStyle;
      var angle = 0;
      var focus = {x: 0, y: 0};

      &#x2F;&#x2F; additional offset
      var shift = 0;
      &#x2F;&#x2F; scale factor for offset
      var expansion = 1;

      if (fillStyle.type_ == &#x27;gradient&#x27;) {
        var x0 = fillStyle.x0_ &#x2F; this.arcScaleX_;
        var y0 = fillStyle.y0_ &#x2F; this.arcScaleY_;
        var x1 = fillStyle.x1_ &#x2F; this.arcScaleX_;
        var y1 = fillStyle.y1_ &#x2F; this.arcScaleY_;
        var p0 = this.getCoords_(x0, y0);
        var p1 = this.getCoords_(x1, y1);
        var dx = p1.x - p0.x;
        var dy = p1.y - p0.y;
        angle = Math.atan2(dx, dy) * 180 &#x2F; Math.PI;

        &#x2F;&#x2F; The angle should be a non-negative number.
        if (angle &lt; 0) {
          angle += 360;
        }

        &#x2F;&#x2F; Very small angles produce an unexpected result because they are
        &#x2F;&#x2F; converted to a scientific notation string.
        if (angle &lt; 1e-6) {
          angle = 0;
        }
      } else {
        var p0 = this.getCoords_(fillStyle.x0_, fillStyle.y0_);
        var width  = max.x - min.x;
        var height = max.y - min.y;
        focus = {
          x: (p0.x - min.x) &#x2F; width,
          y: (p0.y - min.y) &#x2F; height
        };

        width  &#x2F;= this.arcScaleX_ * Z;
        height &#x2F;= this.arcScaleY_ * Z;
        var dimension = m.max(width, height);
        shift = 2 * fillStyle.r0_ &#x2F; dimension;
        expansion = 2 * fillStyle.r1_ &#x2F; dimension - shift;
      }

      &#x2F;&#x2F; We need to sort the color stops in ascending order by offset,
      &#x2F;&#x2F; otherwise IE won&#x27;t interpret it correctly.
      var stops = fillStyle.colors_;
      stops.sort(function(cs1, cs2) {
        return cs1.offset - cs2.offset;
      });

      var length = stops.length;
      var color1 = stops[0].color;
      var color2 = stops[length - 1].color;
      var opacity1 = stops[0].alpha * this.globalAlpha;
      var opacity2 = stops[length - 1].alpha * this.globalAlpha;

      var colors = [];
      for (var i = 0; i &lt; length; i++) {
        var stop = stops[i];
        colors.push(stop.offset * expansion + shift + &#x27; &#x27; + stop.color);
      }

      &#x2F;&#x2F; When colors attribute is used, the meanings of opacity and o:opacity2
      &#x2F;&#x2F; are reversed.
      lineStr.push(&#x27;&lt;g_vml_:fill type=&quot;&#x27;, fillStyle.type_, &#x27;&quot;&#x27;,
                   &#x27; method=&quot;none&quot; focus=&quot;100%&quot;&#x27;,
                   &#x27; color=&quot;&#x27;, color1, &#x27;&quot;&#x27;,
                   &#x27; color2=&quot;&#x27;, color2, &#x27;&quot;&#x27;,
                   &#x27; colors=&quot;&#x27;, colors.join(&#x27;,&#x27;), &#x27;&quot;&#x27;,
                   &#x27; opacity=&quot;&#x27;, opacity2, &#x27;&quot;&#x27;,
                   &#x27; g_o_:opacity2=&quot;&#x27;, opacity1, &#x27;&quot;&#x27;,
                   &#x27; angle=&quot;&#x27;, angle, &#x27;&quot;&#x27;,
                   &#x27; focusposition=&quot;&#x27;, focus.x, &#x27;,&#x27;, focus.y, &#x27;&quot; &#x2F;&gt;&#x27;);
    } else {
      lineStr.push(&#x27;&lt;g_vml_:fill color=&quot;&#x27;, color, &#x27;&quot; opacity=&quot;&#x27;, opacity,
                   &#x27;&quot; &#x2F;&gt;&#x27;);
    }

    lineStr.push(&#x27;&lt;&#x2F;g_vml_:shape&gt;&#x27;);

    this.element_.insertAdjacentHTML(&#x27;beforeEnd&#x27;, lineStr.join(&#x27;&#x27;));
  };

  contextPrototype.fill = function() {
    this.stroke(true);
  }

  contextPrototype.closePath = function() {
    this.currentPath_.push({type: &#x27;close&#x27;});
  };

  &#x2F;**
   * @private
   *&#x2F;
  contextPrototype.getCoords_ = function(aX, aY) {
    var m = this.m_;
    return {
      x: Z * (aX * m[0][0] + aY * m[1][0] + m[2][0]) - Z2,
      y: Z * (aX * m[0][1] + aY * m[1][1] + m[2][1]) - Z2
    }
  };

  contextPrototype.save = function() {
    var o = {};
    copyState(this, o);
    this.aStack_.push(o);
    this.mStack_.push(this.m_);
    this.m_ = matrixMultiply(createMatrixIdentity(), this.m_);
  };

  contextPrototype.restore = function() {
    copyState(this.aStack_.pop(), this);
    this.m_ = this.mStack_.pop();
  };

  function matrixIsFinite(m) {
    for (var j = 0; j &lt; 3; j++) {
      for (var k = 0; k &lt; 2; k++) {
        if (!isFinite(m[j][k]) || isNaN(m[j][k])) {
          return false;
        }
      }
    }
    return true;
  }

  function setM(ctx, m, updateLineScale) {
    if (!matrixIsFinite(m)) {
      return;
    }
    ctx.m_ = m;

    if (updateLineScale) {
      &#x2F;&#x2F; Get the line scale.
      &#x2F;&#x2F; Determinant of this.m_ means how much the area is enlarged by the
      &#x2F;&#x2F; transformation. So its square root can be used as a scale factor
      &#x2F;&#x2F; for width.
      var det = m[0][0] * m[1][1] - m[0][1] * m[1][0];
      ctx.lineScale_ = sqrt(abs(det));
    }
  }

  contextPrototype.translate = function(aX, aY) {
    var m1 = [
      [1,  0,  0],
      [0,  1,  0],
      [aX, aY, 1]
    ];

    setM(this, matrixMultiply(m1, this.m_), false);
  };

  contextPrototype.rotate = function(aRot) {
    var c = mc(aRot);
    var s = ms(aRot);

    var m1 = [
      [c,  s, 0],
      [-s, c, 0],
      [0,  0, 1]
    ];

    setM(this, matrixMultiply(m1, this.m_), false);
  };

  contextPrototype.scale = function(aX, aY) {
    this.arcScaleX_ *= aX;
    this.arcScaleY_ *= aY;
    var m1 = [
      [aX, 0,  0],
      [0,  aY, 0],
      [0,  0,  1]
    ];

    setM(this, matrixMultiply(m1, this.m_), true);
  };

  contextPrototype.transform = function(m11, m12, m21, m22, dx, dy) {
    var m1 = [
      [m11, m12, 0],
      [m21, m22, 0],
      [dx,  dy,  1]
    ];

    setM(this, matrixMultiply(m1, this.m_), true);
  };

  contextPrototype.setTransform = function(m11, m12, m21, m22, dx, dy) {
    var m = [
      [m11, m12, 0],
      [m21, m22, 0],
      [dx,  dy,  1]
    ];

    setM(this, m, true);
  };

  &#x2F;******** STUBS ********&#x2F;
  contextPrototype.clip = function() {
    &#x2F;&#x2F; TODO: Implement
  };

  contextPrototype.arcTo = function() {
    &#x2F;&#x2F; TODO: Implement
  };

  contextPrototype.createPattern = function() {
    return new CanvasPattern_;
  };

  &#x2F;&#x2F; Gradient &#x2F; Pattern Stubs
  function CanvasGradient_(aType) {
    this.type_ = aType;
    this.x0_ = 0;
    this.y0_ = 0;
    this.r0_ = 0;
    this.x1_ = 0;
    this.y1_ = 0;
    this.r1_ = 0;
    this.colors_ = [];
  }

  CanvasGradient_.prototype.addColorStop = function(aOffset, aColor) {
    aColor = processStyle(aColor);
    this.colors_.push({offset: aOffset,
                       color: aColor.color,
                       alpha: aColor.alpha});
  };

  function CanvasPattern_() {}

  &#x2F;&#x2F; set up externs
  G_vmlCanvasManager = G_vmlCanvasManager_;
  CanvasRenderingContext2D = CanvasRenderingContext2D_;
  CanvasGradient = CanvasGradient_;
  CanvasPattern = CanvasPattern_;

})();

} &#x2F;&#x2F; if

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>
